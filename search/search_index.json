{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":""},{"location":"#home","title":"Home","text":"<p>Hyli is the new proof-powered L1 to build the next generation of apps onchain.</p>"},{"location":"#navigation","title":"Navigation","text":"<ul> <li> <p> Introduction</p> <p>A quick overview of Hyli, the new proof-powered L1 to build the next generation of apps onchain.</p> <p> Introduction</p> </li> <li> <p> Quickstart</p> <p>Get started with Hyli in just a few minutes with a step-by-step annotated quickstart.</p> <p> Quickstart</p> </li> <li> <p> Concepts</p> <p>Hyli-specific concepts and Hyli's spin on industry classics explained in detail.</p> <p> Concepts</p> </li> <li> <p> Tooling</p> <p>Hyli tooling to improve your building experience.</p> <p> Tooling</p> </li> </ul> <p>Reach out on Telegram or open an issue if you need assistance or wish to provide feedback on the documentation: we're always looking to improve.</p>"},{"location":"#useful-links","title":"Useful links","text":"<ul> <li> Rust node</li> <li> Example contracts</li> <li> Website</li> <li> Hyli blog</li> </ul> <p>Vibe coders, use our LLMs.txt file!</p>"},{"location":"#lets-talk","title":"Let's talk!","text":"<p>Reach out to the team for more information:</p>  Github  Twitter  Farcaster  LinkedIn  Youtube  Telegram Hyli @hyli_org @Hyli Hyli @Hyli Hyli"},{"location":"introduction/","title":"Introduction to Hyli","text":""},{"location":"introduction/#introduction-to-hyli","title":"Introduction to Hyli","text":"<p>Hyli is the new proof-powered L1 to build the next generation of apps onchain.</p> <p>An unchained application runs offchain and settles onchain. It benefits from the Web2 user experience and the security of Web3.</p>"},{"location":"introduction/#why-choose-hyli","title":"Why choose Hyli","text":"<p>Hyli is built for speed, flexibility, and seamless blockchain integration:</p> <ul> <li>Ultra-fast ZK verification on a sovereign L1.</li> <li>No EVMs, no bottlenecks: run complex logic off-chain, submit a proof, and we\u2019ll verify it natively before settling onchain.</li> <li>Frictionless onboarding: authenticate with any identity provider, no wallets required.</li> <li>High throughput, low latency with pipelined proving.</li> <li>Choose your tools: use any proving scheme, any language.</li> <li>Seamless interoperability: call other contracts with proof composition.</li> <li>Web2 speed, Web3 security: we use Autobahn consensus for DA &amp; settlement.</li> </ul>"},{"location":"introduction/#how-hyli-works","title":"How Hyli works","text":"<p>Here\u2019s what happens when you use Hyli\u2019s next-generation L1:</p> <p></p> <ol> <li>Sequencing: Send a provable blob of information to Hyli: say what information you expect to prove later. We'll sequence the transaction immediately and give you time to prove it. Read more about pipelined proving.</li> <li>Proof submission: when the proofs for your transaction are ready, send them to Hyli.</li> <li>Verification: Hyli validators receive the transaction. They verify the proofs natively, without the limitations of a bulky virtual machine.</li> <li>Consensus: if the proofs are valid, Hyli settles your transaction's state onchain. You're good to go!</li> </ol> <p>With this system, execution and storage happen anywhere you like. You only need a fast and trustworthy verifier: that\u2019s Hyli.</p>"},{"location":"concepts/","title":"\ud83d\udca1 Concepts","text":""},{"location":"concepts/#concepts","title":"Concepts","text":"<p>Welcome to the developer documentation for Hyli.</p> <p>This section includes general documentation topics. You can also refer to our Getting Started step-by-step guide.</p>"},{"location":"concepts/#hyli-specific-docs-on-industry-concepts","title":"Hyli-specific docs on industry concepts","text":"<ul> <li> <p> Apps</p> <p>Most app information stays off-chain.</p> <p> Read more</p> </li> <li> <p> Transactions</p> <p>Understand blob transactions and proof transactions.</p> <p> Read more</p> </li> <li> <p> Proof generation</p> <p>Learn how to prove your blobs for Hyli.</p> <p> Read more</p> </li> <li> <p> Identity</p> <p>Any app can be an identity on Hyli.</p> <p> Read more</p> </li> </ul>"},{"location":"concepts/#hyli-specific-concepts","title":"Hyli-specific concepts","text":"<ul> <li> <p> Proof composition</p> <p>Compose several proof systems and manage cross-contract composition seamlessly.</p> <p> Read more</p> </li> <li> <p> Pipelined proving</p> <p>Separate sequencing and settlement and remove proving times from your app's critical path.</p> <p> Read more</p> </li> </ul>"},{"location":"concepts/#more","title":"More","text":"<ul> <li> <p> Hyli vs. vintage blockchains</p> <p>Learn the main differences between Hyli and traditional blockchains.</p> <p> Read more</p> </li> </ul>"},{"location":"concepts/apps/","title":"Apps on Hyli","text":""},{"location":"concepts/apps/#apps-on-hyli","title":"Apps on Hyli","text":"<p>Hyli is a fully programmable blockchain designed for efficient data storage. Hyli only keeps the essential information needed to validate app proofs, ensuring that apps are lightweight and performant.</p> <p>Unlike traditional blockchains, which store all app data onchain, Hyli separates execution data (managed offchain by each application) from onchain data, which can be retrieved via our ABI.</p>"},{"location":"concepts/apps/#onchain-app-data","title":"Onchain app data","text":"<p>Hyli apps store the following data onchain:</p> <ul> <li>Name: the unique identifier for the contract</li> <li>Verifier: the proof system used (e.g., \"risc0\")</li> <li>Program ID: the unique identifier for the program within that proof system</li> <li>State digest: current state commitment of the contract</li> </ul>"},{"location":"concepts/apps/#explanation-of-the-contract-fields","title":"Explanation of the contract fields","text":""},{"location":"concepts/apps/#name","title":"Name","text":"<p>The contract name must be unique.</p>"},{"location":"concepts/apps/#verifier-and-program-id","title":"Verifier and program ID","text":"<p>Apps on Hyli rely on a pairing of a zero-knowledge proof scheme (verifier) and a program identifier. Together, these components validate contract proofs.</p> <p>See the verifier scheme for each supported proving scheme in this reference page.</p>"},{"location":"concepts/apps/#state-digest","title":"State digest","text":"<p>The state digest represents the contract's current state commitment. It allows Hyli to guarantee its integrity. It can take any form as long as it fulfills this purpose.</p> <p>The state digest can be expressed as a hash or even a serialization of the state if it's small enough.</p>"},{"location":"concepts/apps/#smart-contract-abi","title":"Smart contract ABI","text":"<p>All inputs in Hyli apps must be known at proof generation time. This includes elements like the <code>tx_hash</code> which are typically available only at execution time on other blockchains.</p> <p>Here is the Rust structure specifying the output of a Hyli app:</p> <pre><code>pub struct HyleOutput {\n    pub version: u32,\n    pub initial_state: StateDigest,\n    pub next_state: StateDigest,\n    pub identity: Identity,\n    pub index: BlobIndex,\n    pub blobs: Vec&lt;u8&gt;,\n    pub tx_hash: TxHash,\n    pub success: bool,\n    pub tx_ctx: Option&lt;TxContext&gt;,\n    pub registered_contracts: Vec&lt;RegisterContractEffect&gt;,\n    pub program_outputs: Vec&lt;u8&gt;, \n}\n</code></pre>"},{"location":"concepts/apps/#version","title":"Version","text":"<p>For now, <code>version</code> should always be set to 1.</p>"},{"location":"concepts/apps/#initial-state-and-next-state","title":"Initial state and next state","text":"<p>These fields define state transitions.</p> <ul> <li><code>initial_state</code>: must match the onchain <code>state_digest</code> before the transaction. If they don't match, the state transition is invalid.</li> <li><code>next_state</code>: Represents the new onchain <code>state_digest</code> after the transaction.</li> </ul> <p>In the future, <code>state_digest</code> size will be limited and fees will depend on proof size (which is affected by the digest's size). Keep them small!</p>"},{"location":"concepts/apps/#identity","title":"Identity","text":"<p>Info</p> <p>Read our identity documentation for details.</p> <p>Identity consists of:</p> <ol> <li>An identifier;</li> <li>The name of the contract that the proof was generated for.</li> </ol> <p>Example</p> <p>A contract verifying Ethereum EOAs might have an identity like <code>0x1234...5678@eth_eoa</code> where the first part matches a regular Ethereum address and <code>eth_eoa</code> is the name of the contract.</p> <p>For simplicity, we recommend using the pre-built Hyli wallet.</p>"},{"location":"concepts/apps/#blob-index-and-blobs","title":"Blob index and blobs","text":"<p>Each blob transaction includes multiple blobs:</p> <ul> <li><code>index</code> uniquely identifies a blob within a transaction.</li> <li><code>blobs</code> is a list of all blobs included in the transaction.</li> </ul>"},{"location":"concepts/apps/#tx-hash","title":"TX Hash","text":"<p><code>tx_hash</code> is the blob Transaction's hash.</p> <p>The protocol does not validate this field and <code>tx_hash</code> may be deprecated in later versions.</p>"},{"location":"concepts/apps/#success","title":"Success","text":"<p>This boolean field indicates whether the proof is for a successful or failed transactions. It can be used to prove that a transaction is invalid.</p> <p>If a proof returns <code>success = false</code>, the whole blob transaction will fail. In that case, there is no need to generate proofs for other blobs.</p>"},{"location":"concepts/apps/#transaction-context","title":"Transaction context","text":"<p>Transaction context allows the contract to know in which block (hash, height, timestamp) the blob transaction has been sequenced.</p> <p>This field is optional. If left empty, it will not be validated by Hyli or usable by the program.</p>"},{"location":"concepts/apps/#registered-contracts","title":"Registered contracts","text":"<p>A list of new contracts to register, which can be used to self-upgrade a contract.</p>"},{"location":"concepts/apps/#other-program-specific-outputs","title":"Other program-specific outputs","text":"<p>Apps can generate additional outputs as proof data. These outputs ensure data availability.</p>"},{"location":"concepts/apps/#events","title":"Events","text":"<p>Hyli does not use traditional events. Instead, it relies on blobs, which serve as containers for offchain data.</p>"},{"location":"concepts/hyli-vs-vintage-blockchains/","title":"Hyli vs. vintage blockchains","text":""},{"location":"concepts/hyli-vs-vintage-blockchains/#hyli-vs-vintage-blockchains","title":"Hyli vs. vintage blockchains","text":"<p>If you're used to traditional blockchains such as Ethereum or Solana, keep these Hyli characteristics in mind.</p>"},{"location":"concepts/hyli-vs-vintage-blockchains/#no-evm-or-execution-layer","title":"No EVM or execution layer","text":"<p>Hyli does not include a Virtual Machine.</p> <p>There is no dedicated execution engine or specific programming language (like Solidity) you should use.</p> <p>Our approach is simple: onchain, we verify zero-knowledge proofs natively. Offchain, you do everything else the way you prefer. This gives you higher throughput, faster finality, and lower gas fees.</p>"},{"location":"concepts/hyli-vs-vintage-blockchains/#minimal-onchain-state","title":"Minimal onchain state","text":"<p>The network maintains proofs of state transitions rather than the entire onchain state.</p> <p>Transactions on Hyli verify and settle transitions without storing full intermediary states onchain.</p> <p>This architecture reduces storage overhead and promotes scalability while maintaining trustlessness.</p>"},{"location":"concepts/hyli-vs-vintage-blockchains/#no-wallets","title":"No wallets","text":"<p>Stop asking yourself, \"Which wallet do I use? How do I bridge?\". You don\u2019t need to worry about that with Hyli: any identity that can produce a valid proof can be integrated in your Hyli wallet.</p>"},{"location":"concepts/hyli-vs-vintage-blockchains/#every-app-is-a-rollup","title":"Every app is a rollup","text":"<p>On Hyli, there is one general-purpose blockchain, and every app is its own based ZK-rollup, removing the problems associated with fragmentation.</p> <p>An app\u2019s transactions are sequenced directly on the Hyli Layer 1. They are split into a blob transaction, which allows for pipelined proving, and a proof transaction to store the state commitment onchain.</p>"},{"location":"concepts/hyli-vs-vintage-blockchains/#privacy-is-built-in","title":"Privacy is built-in","text":"<p>Unlike Ethereum, where privacy solutions must be implemented on top of the platform, Hyli integrates privacy features natively.</p> <p>The proof is public, but your inputs don't need to be, as execution happens offchain.</p>"},{"location":"concepts/identity/","title":"Identity management","text":""},{"location":"concepts/identity/#identity-management","title":"Identity management","text":"<p>Coming soon.</p> <p>See also Wallet.</p>"},{"location":"concepts/pipelined-proving/","title":"Pipelined proving","text":""},{"location":"concepts/pipelined-proving/#pipelined-proving","title":"Pipelined proving","text":""},{"location":"concepts/pipelined-proving/#the-problem-base-state-conflicts","title":"The problem: base state conflicts","text":"<p>The Hyli Layer 1 ensures both privacy and scalability by verifying only the state transitions of apps, rather than re-executing them. This approach reduces computational overhead but introduces a critical issue for provable applications: base state conflicts.</p> <p>An app with a lot of usage will see conflicting operations, where multiple transactions reference the same base state, waiting for the previous state change to be settled.</p> <p>The time spent generating proofs delays transaction finality. Proofs require accurate timestamps, but users can't predict when their transaction will be sequenced.</p> <p>This causes parallelization limits: multiple transactions may reference the same base state, creating invalid proofs when one is settled before the other.</p> <p>We solve these issues by splitting sequencing from settlement; an operation includes two transactions.</p>"},{"location":"concepts/pipelined-proving/#blob-and-proof-transactions","title":"Blob- and proof-transactions","text":"<p>Read more on the content of blob and proof transactions on our transaction page.</p> <p>To address base state conflicts, Hyli splits operations into two transactions:</p> <ol> <li>Blob-transaction: outlines a state change for sequencing.</li> <li>Proof-transaction: provides a proof of the state change for settlement.</li> </ol> <p>From Hyli\u2019s perspective, the blob-transaction's content does not matter: it simply represents incoming information that your contract will process. For a developer, sequencing provides you with a fixed order and timestamp before proving begins. Once the transactions are sequenced, the provers can easily know upon which state they should base their proof. As a developer, you can also decide on how much information is disclosed in your blob-transaction: this is app-specific.</p> <p>Settlement happens when the corresponding proof transaction is verified and added to a block. During settlement, unproven blob transactions linked to the contract are executed in their sequencing order.</p> <p></p> <p>This separation solves all three issues shown above. The blob transaction immediately reserves a place in execution order, allowing proof generation to run without blocking other transactions. The sequencing provides an immutable timestamp, so provers know which base state to use when generating proofs and can parallelize actions.</p>"},{"location":"concepts/pipelined-proving/#unprovable-transactions","title":"Unprovable transactions","text":"<p>Even with pipelined proving, sequenced transactions that never settle can slow down the network.</p> <p>To remove this risk, Hyli enforces timeouts for blob transactions.</p> <p>Each blob transaction is assigned a specific time limit for the associated proof to be submitted and verified. Subsequent transactions can proceed without waiting indefinitely.</p>"},{"location":"concepts/pipelined-proving/#failed-transactions","title":"Failed transactions","text":"<p>If the proof isn't submitted before timeout, or if the submitted proof is invalid, the transaction is included in the block, marked as Rejected, and is ignored for state updates.</p> <p>The inclusion of the unproven transaction in the block ensures transparency, as the transaction data remains accessible.</p> <p></p>"},{"location":"concepts/proof-composition/","title":"Proof composition","text":""},{"location":"concepts/proof-composition/#proof-composition","title":"Proof composition","text":""},{"location":"concepts/proof-composition/#the-problem-clunky-interactions","title":"The problem: clunky interactions","text":"<p>In zero-knowledge systems, coordinating multiple proofs is complex. Cross-contract calls often rely on recursive verification, where Program A verifies a proof of the correct execution of Program B. This is inefficient and creates overhead at the proof generation and verification stages.</p> <p>The situation worsens when different proving schemes are involved. Most zero-knowledge systems force you to write your proofs in a unified scheme. By doing that, you lose all the advantages of specialization.</p> <p>Different proving schemes answer different needs. Some proof systems are best for client-side proving; others allow developers to use general-purpose programming languages.</p>"},{"location":"concepts/proof-composition/#the-solution-proof-composition","title":"The solution: proof composition","text":"<p>Hyli introduces native proof composition, allowing proofs to interact while remaining independent. Each proof can use the most suitable language and proving scheme, all within a single transaction.</p> <p>You benefit from composition when your transaction:</p> <ul> <li>Involves multiple applications</li> <li>Includes proofs in different languages or proving schemes</li> <li>Combines heterogeneous logic where different tools are ideal</li> </ul> <p>If everything fits cleanly within one proof, there is no composition.</p>"},{"location":"concepts/proof-composition/#cross-contract-calls-with-proof-composition","title":"Cross-contract calls with proof composition","text":"<p>Instead of recursion, Hyli lets a program declare: \"This only applies if all referenced blobs are valid.\" During settlement, all proofs are included in one transaction. Hyli verifies them together. If any proof fails, the entire transaction fails.</p> <p>This model:</p> <ul> <li>removes the need for embedded recursion;</li> <li>improves developer experience;</li> <li>reduces gas costs;</li> <li>enables parallel proving.</li> </ul>"},{"location":"concepts/proof-composition/#mixing-proof-schemes","title":"Mixing proof schemes","text":"<p>Since proofs in Hyli remain independent, each proof in a composed transaction can use its own proving scheme. Proofs are verified separately, eliminating the need to compromise for compatibility. This also enables cross-contract calls between applications using different proof systems.</p> <p>You can:</p> <ul> <li>batch heterogeneous proofs;</li> <li>call between contracts using different systems;</li> <li>choose the best proving scheme for each proof.</li> </ul>"},{"location":"concepts/proof-composition/#how-hyli-settles-multiple-proofs","title":"How Hyli settles multiple proofs","text":"<p>When a transaction includes multiple proofs, Hyli begins verifying each proof as soon as it's ready. If one fails or times out, the entire transaction is rejected.</p> <p>Proof generation is parallelized as all proofs are independent. Verification is asynchronous thanks to pipelined proving.</p>"},{"location":"concepts/proof-composition/#writing-a-cross-contract-call","title":"Writing a cross-contract call","text":"<p>Your program doesn't need to verify another program\u2019s execution directly. Instead, your contract declares claims about other apps:</p> <pre><code>MoneyApp::transfer(10, A, B) == true\nTicketApp::get(A) == ticket\n</code></pre> <p></p> <p>Each claim consists of:</p> <ul> <li>The application (MoneyApp, TicketApp)</li> <li>The function (transfer, get)</li> <li>Parameters</li> <li>A result assertion (== true, == ticket)</li> </ul> <p>See the source code from our example.</p>"},{"location":"concepts/proof-composition/#delegating-identity","title":"Delegating identity","text":"<p>Each transaction in Hyli is signed by a single identity blob. By default, this identity authorizes all blobs in the transaction.</p> <p>For cross-contract composition, Hyli supports callees, blobs that run under a different identity.</p> <p>This lets contracts trigger delegated actions without needing nested calls or recursion.</p> <p>Consider an AMM:</p> <ol> <li>Alice signs and submits a swap</li> <li>The AMM blob executes <code>swap()</code></li> <li><code>swap()</code> lists <code>transfer()</code> and <code>transferFrom()</code> as callees</li> <li>These callees run as if the AMM signed them</li> </ol> <p></p>"},{"location":"concepts/proof-composition/#caller","title":"Caller","text":"<p>The caller is the identity under which a blob executes. By default, it\u2019s the transaction signer (e.g., <code>Alice.hydentity</code>).</p> <p>If a blob is a callee, its caller becomes the blob that declared it.</p>"},{"location":"concepts/proof-composition/#callee","title":"Callee","text":"<p>A callee is a blob that runs on behalf of another blob. This lets contracts perform delegated actions without initiating their own transactions.</p> <p>For example:</p> <ul> <li>Alice signs and submits a transaction that includes a blob for an AMM swap</li> <li>The AMM swap blob declares two callees: <code>transfer</code> and <code>transferFrom</code></li> <li>These execute with the AMM as the caller</li> </ul>"},{"location":"concepts/proof-composition/#execution-and-validation","title":"Execution and validation","text":"<p>Each callee:</p> <ul> <li>Verifies that the caller blob explicitly listed it as a callee</li> <li>Checks authorization logic (e.g., <code>transferFrom</code> checks for prior <code>approve</code>)</li> </ul> <p>This approach lets users delegate logic to contracts without nested transactions, maintaining clarity and flatness in Hyli\u2019s execution model.</p>"},{"location":"concepts/proof-generation/","title":"Proof generation and submission","text":""},{"location":"concepts/proof-generation/#proof-generation-and-submission","title":"Proof generation and submission","text":"<p>Hyli allows you to build unchained applications by leveraging zero-knowledge proofs. They allow you to avoid onchain execution, guarantee privacy, and customize your application while maintaining composability with other apps.</p> <p>With Hyli, generate your proof wherever you prefer, then send it for native onchain verification and settlement. This process enables scalable, modular applications with customizable proving schemes.</p> <p>If you're a complete beginner with zero-knowledge proofs, our no-code introduction might help.</p>"},{"location":"concepts/proof-generation/#zero-knowledge-proofs-on-hyli","title":"Zero-knowledge proofs on Hyli","text":""},{"location":"concepts/proof-generation/#choose-what-you-prove","title":"Choose what you prove","text":"<p>Each application defines its proof logic. This means that each application developer can decide what information gets proven: for Hyli, proof settlement is a Success or a Failure. You define what that means for your app.</p> <p>Each app developer also defines what the public and private inputs of their app will be: what information should remain private and what should go onchain?</p>"},{"location":"concepts/proof-generation/#choose-how-you-prove","title":"Choose how you prove","text":"<p>We support as many proving schemes we can, giving you the flexibility to choose the most suitable protocol for your specific use case. Read more about our supported proving schemes.</p> <p>We also verify these natively, without the need for a ZK proof:</p> <ul> <li>sha3_256</li> <li>BLST signatures</li> <li>Secp256k1 signatures</li> </ul> <p>There are many ZK languages. Hyli aims to verify as many as possible.</p> <p>DSLs, like Circom, are specific languages that usually compile down to a specific circuit. They're good, but they're complex and may have a high learning curve.</p> <p>zkVMs prove the correct execution of arbitrary code. They allow you to build ZK applications in a certain language without having to build a circuit around it. There are two main types of zkVMs: Cairo and RISC-V. You can benchmark your Rust code and find the best zkVM for your needs with the any-zkvm template.</p> <p>We will support more types, including Cairo-based zkVMs and DSLs, in the future, and plan to support all major proving schemes eventually.</p>"},{"location":"concepts/proof-generation/#how-to-generate-proofs","title":"How to generate proofs","text":""},{"location":"concepts/proof-generation/#choose-where-you-prove","title":"Choose where you prove","text":"<p>Each application can generate its proof in whichever place fits best.</p> Pros Cons When to use Client-side (browser, mobile app) Maximum privacyData ownership Requires robust client-side hardware Personal data that should remain private External prover or proving market No client-side costs or constraintsOffload proof generation to the experts Requires trusting the external prover with your inputs Resource-intensive and not privacy-sensitive proofs By the application itself Simple UXNo dependenciesCode can be private Higher infrastructure needsPotential liveness issue Confidential or centralized applications"},{"location":"concepts/proof-generation/#autoproving-through-our-scaffold","title":"Autoproving through our scaffold","text":"<p>Hyli\u2019s scaffold includes a built-in AutoProver service that automatically detects transactions related to your contract. It generates the corresponding proof and submits the associated proof transaction to Hyli.</p> <p>With autoproving in place, you don\u2019t need to manage custom proving flows. Just write your contract and connect a frontend\u2014the scaffold handles everything else. This setup is ideal for projects where you want minimal backend setup and an easier onboarding experience.</p> <p>Visit the scaffold repository or follow the quickstart instructions.</p>"},{"location":"concepts/proof-generation/#our-proof-generation-partners","title":"Our proof generation partners","text":"<p>If you choose to work with an external prover or proving market, you can choose from one of our partners in that area and benefit from a better Hyli integration.</p>"},{"location":"concepts/proof-generation/#submitting-a-proof-to-hyli","title":"Submitting a proof to Hyli","text":"<p>Read more about the transaction lifecycle on our transactions overview.</p> <p>First, your application sends a blob transaction to Hyli.</p> <p>Thanks to pipelined proving, once a transaction is submitted, it is sequenced.</p> <p>You can then start generating your proof using the sequenced virtual base state as the base state for your operation.</p> <p>Once sent, the proof goes through Hyli\u2019s native verification, removing the need for verifier contracts.</p> <p>Once verified, the proof is settled onchain. Use this settled state to update your app accordingly outside of Hyli.</p>"},{"location":"concepts/proof-generation/#external-resources","title":"External resources","text":"<ul> <li>Zero-knowledge proofs explained at 5 levels of difficulty (22')</li> <li>awesome-zk link repository on GitHub</li> <li>Hyli's very simple introduction to zero-knowledge proofs</li> <li>Lauri Peltonen's blog series on ZK</li> </ul>"},{"location":"concepts/transaction/","title":"Transactions on Hyli","text":""},{"location":"concepts/transaction/#transactions-on-hyli","title":"Transactions on Hyli","text":"<p>Hyli introduces a novel transaction model that separates intent from proof, optimizing for scalability and privacy.</p> <p>Unlike traditional blockchains, where transactions are executed and proven in a single step, Hyli employs a two-step process called pipelined proving:</p> <ol> <li>Blob-transaction: outlines a state change for sequencing.</li> <li>Proof-transaction: provides a proof of the state change for settlement.</li> </ol> <p>Each proof transaction verifies a single blob, unless you use recursion. If a blob transaction contains multiple blobs, each requires a separate proof.</p> <p>Once all blobs are proven, the blob transaction is settled, and the referenced contract states are updated.</p>"},{"location":"concepts/transaction/#blob-transaction-structure","title":"Blob transaction structure","text":"<p>A blob transaction consists of:</p> <ul> <li>An identity string. See identity.</li> <li>A list of blobs, each containing:</li> <li>A contract name (string).</li> <li>A data field (binary), which the contract parses.</li> </ul>"},{"location":"concepts/transaction/#proof-transaction-structure","title":"Proof transaction structure","text":"<p>A proof transaction includes:</p> <ul> <li>A contract name (string).</li> <li>Proof data (binary), containing:</li> <li>A zero-knowledge proof.</li> <li>The app output.</li> </ul> <p>For Risc0 and SP1, the proof data's app output follows <code>HyleOutput</code> as defined in the smart contract ABI.</p>"},{"location":"concepts/transaction/#example-token-transfer","title":"Example: token transfer","text":"<p>A token transfer involves two blobs in a blob transaction:</p> <ul> <li>Identity blob: Verifies the sender\u2019s identity and authorizes the transfer.</li> <li>Transfer blob: Executes the token transfer.</li> </ul> <p>Each blob requires a corresponding proof transaction.</p>"},{"location":"concepts/transaction/#blob-transaction","title":"Blob transaction","text":"<pre><code>{\n    \"identity\": \"bob.hydentity\",\n    \"blobs\": [\n        {\n            \"contract_name\": \"hydentity\",\n             // Binary data for the operation of hydentity contract\n             // VerifyIdentity { account: \"bob.hydentity\", nonce: \"2\" }\n            \"data\": \"[...]\" \n        },\n        {\n            \"contract_name\": \"hyllar\",\n             // Binary data for the operation of hyllar contract\n             // Transfer { recipient: \"alice.hydentity\", ammount: \"20\" }\n            \"data\": \"[...]\"\n        }\n    ]\n}\n</code></pre>"},{"location":"concepts/transaction/#proof-transactions","title":"Proof transactions","text":""},{"location":"concepts/transaction/#identity-proof","title":"Identity proof","text":"<pre><code>{\n    \"contract_name\": \"hydentity\",\n    \"proof\": \"[...]\"\n}\n</code></pre> <p>The binary proof's output includes:</p> <ul> <li>Initial state: <code>bob.hydentity</code> nonce = 1.</li> <li>Next state: <code>bob.hydentity</code> nonce = 2.</li> <li>Index: 0 (first blob in the transaction).</li> </ul> <p>and</p> <pre><code>{\n    \"contract_name\": \"hyllar\",\n    \"proof\": \"[...]\"\n}\n</code></pre> <p>The binary proof's output includes:</p> <ul> <li>Initial state: <code>bob.hydentity</code> balance = 100, <code>alice.hydentity</code> balance = 0.</li> <li>Next state: <code>bob.hydentity</code> balance = 80, <code>alice.hydentity</code> balance = 20.</li> <li>Index: 1 (second blob in the transaction).</li> </ul>"},{"location":"quickstart/","title":"\ud83c\udfc1 Quickstart","text":""},{"location":"quickstart/#quickstart","title":"Quickstart","text":"<p>Welcome to the Quickstart guide for Hyli.</p> <p>It uses several examples to help you start building as soon as possible.</p> <p>Run the scaffold locally</p> <p>Where it all begins.</p> <p>Build your app</p> <p>Using our scaffold repository, set up your application.</p>"},{"location":"quickstart/devnet/","title":"Run the scaffold locally","text":""},{"location":"quickstart/devnet/#run-the-scaffold-locally","title":"Run the scaffold locally","text":""},{"location":"quickstart/devnet/#prerequisites","title":"Prerequisites","text":"<ul> <li>Install Rust (you'll need <code>rustup</code> and Cargo).</li> <li>Install openssl-dev (e.g. <code>apt install openssl-dev</code> or <code>cargo add openssl</code>).</li> <li> <p>Bun (or npm/yarn)</p> </li> <li> <p>For the scaffold example, install RISC Zero and Noir. You can also use SP1.</p> </li> </ul>"},{"location":"quickstart/devnet/#run-a-node-locally","title":"Run a node locally","text":"<p>Clone the Hyli node.</p> <p>Run:</p> <pre><code>rm -rf data_node &amp;&amp; RISC0_DEV_MODE=true SP1_PROVER=mock cargo run -- --pg\ngit checkout v0.13.1\nrm -rf data_node &amp;&amp; RISC0_DEV_MODE=true SP1_PROVER=mock cargo run -- --pg\n</code></pre> <p>You can now use the Hyli explorer. Select <code>localhost</code> in the upper-right corner.</p> <p>For alternative setups, optional features, and advanced configurations, check out the local node reference page.</p>"},{"location":"quickstart/devnet/#run-the-wallet","title":"Run the wallet","text":"<p>Clone the Wallet repository.</p> <p>Wait until the node has successfully launched.</p> <p>Run:</p> <pre><code>git checkout v0.1.2\nrm -rf data 2&gt;/dev/null || true &amp;&amp; clear &amp;&amp; RISC0_DEV_MODE=true SP1_PROVER=mock cargo run --bin server --release -- -m -a -w\n</code></pre>"},{"location":"quickstart/devnet/#run-the-app-scaffold","title":"Run the app scaffold","text":"<p>Clone the Hyli app scaffold.</p> <p>Launch the server:</p> <pre><code>rm -rf data 2&gt;/dev/null || true &amp;&amp; clear &amp;&amp; RISC0_DEV_MODE=true SP1_PROVER=mock cargo run --bin server --release\n</code></pre> <p>Start the scaffold's UI:</p> <pre><code>cd front\nbun install &amp;&amp; bun run dev\n</code></pre> <p>Everything is now functional. We can now explore the scaffold!</p>"},{"location":"quickstart/scaffold/","title":"Build your app","text":""},{"location":"quickstart/scaffold/#build-your-app","title":"Build your app","text":""},{"location":"quickstart/scaffold/#important-editing-a-contract","title":"IMPORTANT: Editing a contract","text":"<p>If you make changes to the contracts, you need to execute this command in the node, the wallet, and the scaffold to restart them:</p> <pre><code>rm -rf data_node &amp;&amp; RISC0_DEV_MODE=true SP1_PROVER=mock cargo run -- --pg\n</code></pre> <p>If you do not do this, you will see an error about a program id mismatch in the server.</p>"},{"location":"quickstart/scaffold/#how-the-scaffold-is-built","title":"How the scaffold is built","text":"<p>The scaffold comes with a built-in autoprover and server implementation, so you can focus on your contracts and frontend.</p> <p>The scaffold includes the following folders:</p> <ul> <li><code>front/</code>, a basic frontend with a wallet integration;</li> <li><code>contracts/</code>, two Risc0 contracts for a default app;</li> <li><code>server/</code>, the autoprover logic.</li> </ul> <p>The application follows a client-server model:</p> <ul> <li>The frontend sends operation requests to the server.</li> <li>The server handles transaction creation, proving, and submission. </li> <li>All interactions go through the Hyli network.</li> </ul>"},{"location":"quickstart/scaffold/#add-your-contracts","title":"Add your contracts","text":"<p>Place your <code>.rs</code> app files in the <code>contracts/</code> directory.</p> <p>For examples of contracts, you can look at examples from our supported proving schemes.</p>"},{"location":"quickstart/scaffold/#add-your-frontend","title":"Add your frontend","text":"<p>Put your frontend code in the <code>front/</code> directory. By default, we've implemented the Hyli wallet.</p> <p>Make sure the frontend connects to the backend at the expected route (<code>/prove</code>, <code>/submit</code>, etc.), or adapt accordingly.</p>"},{"location":"quickstart/scaffold/#start-the-server","title":"Start the server","text":"<p>In the root of the scaffold, start the backend server:</p> <pre><code>RISC0_DEV_MODE=1 cargo run -p server\n</code></pre> <p>This starts the backend service, which handles contract interactions and proofs.</p>"},{"location":"quickstart/scaffold/#open-the-frontend-interface","title":"Open the frontend interface","text":"<p>From the <code>front/</code> directory, install dependencies and run the dev server:</p> <pre><code>cd front\nbun install\nbun run dev\n</code></pre> <p>This starts the local frontend interface to interact with the Hyli network.</p>"},{"location":"reference/","title":"Reference","text":""},{"location":"reference/#reference","title":"Reference","text":"<p>This section provides key reference materials related to Hyli.</p>"},{"location":"reference/devnet/","title":"Local node configuration","text":""},{"location":"reference/devnet/#local-node-configuration","title":"Local node configuration","text":""},{"location":"reference/devnet/#recommended-run-from-source","title":"Recommended: Run from source","text":"<p>For a single-node devnet (consensus disabled) with an indexer, clone the hyli repository and run:</p> <pre><code>cargo run -- --pg\n</code></pre> <p>This command starts a temporary PostgreSQL server and erases its data when you stop the node.</p>"},{"location":"reference/devnet/#optional-persistent-storage","title":"Optional: Persistent storage","text":"<p>For persistent storage, start a standalone PostgreSQL instance:</p> <pre><code># Start PostgreSQL with default configuration:\ndocker run -d --rm --name pg_hyle -p 5432:5432 -e POSTGRES_PASSWORD=postgres postgres\n</code></pre> <p>Then, navigate to the Hyli root and run:</p> <pre><code>cargo run\n</code></pre>"},{"location":"reference/devnet/#alternative-start-with-docker","title":"Alternative: Start with Docker","text":"<p>Use Docker to run a local node. Note that the devnet is unstable and may break with future updates.</p>"},{"location":"reference/devnet/#pull-the-docker-image","title":"Pull the Docker image","text":"<pre><code>docker pull ghcr.io/hyli-org/hyli:v0.12.1\n</code></pre>"},{"location":"reference/devnet/#run-the-docker-container","title":"Run the Docker container","text":"<pre><code>docker run -v ./data:/hyle/data -p 4321:4321 ghcr.io/hyli-org/hyli:v0.12.1\n</code></pre> <p>If you run into an error, try adding the <code>--privileged</code> flag:</p> <pre><code>docker run --privileged -v ./data:/hyle/data -p 4321:4321 ghcr.io/hyli-org/hyli:v0.12.1\n</code></pre> <p>To run with an indexer, add the parameter <code>-e HYLE_RUN_INDEXER=true</code> and set up a running PostgreSQL server with Docker:</p> <pre><code>docker run -d --rm --name pg_hyle -p 5432:5432 -e POSTGRES_PASSWORD=postgres postgres\n</code></pre> <p>And the node linked to it:</p> <pre><code>docker run -v ./data:/hyle/data \\\n    -e HYLE_RUN_INDEXER=true \\\n    -e HYLE_DATABASE_URL=postgres://postgres:postgres@pg_hyle:5432/postgres \\\n    --link pg_hyle \\\n    -p 4321:4321 \\\n    ghcr.io/hyli-org/hyli:v0.7.2\n</code></pre> <p>You can now create your first app.</p> <p>Tip</p> <p>To reset your devnet, delete the ./data folder and restart from Step 1. Otherwise, you risk re-registering a contract that still exists.</p>"},{"location":"reference/devnet/#alternative-build-the-docker-image-locally","title":"Alternative: Build the Docker image locally","text":"<p>If you prefer to build the image from source, run:</p> <pre><code>docker build -t hyli-org/hyli . &amp;&amp; docker run -dit hyli-org/hyli\n</code></pre>"},{"location":"reference/devnet/#configuration","title":"Configuration","text":"<p>You can configure your setup using environment variables or by editing a configuration file.</p>"},{"location":"reference/devnet/#using-a-configuration-file","title":"Using a configuration file","text":"<p>To load settings from a file, place <code>config.toml</code> in your node's working directory. It will be detected automatically at startup.</p> <p>For documentation, see the defaults at src/utils/conf_defaults.toml.</p> <p>For Docker users, mount the config file when running the container:</p> <pre><code>docker run -v ./data:/hyle/data -v ./config.run:/hyle/config.toml -e HYLE_RUN_INDEXER=false -p 4321:4321 -p 1234:1234 ghcr.io/hyli-org/hyli:v0.12.1\ncp ./src/utils/conf_defaults.toml config.toml\n</code></pre> <p>For source users, copy the default config template:</p> <pre><code>cp ./src/utils/conf_defaults.toml config.toml\n</code></pre>"},{"location":"reference/devnet/#using-environment-variables","title":"Using environment variables","text":"<p>All variables can be customized on your single-node instance. The mapping uses 'HYLE_' as a prefix, then '__' where a '.' would be in the config file.</p> <p>e.g.</p> <p><code>id</code> is set with <code>HYLE_ID=\"your_id\"</code>. <code>run_indexer</code> is set with <code>HYLE_RUN_INDEXER=\"true\"</code>. <code>p2p.address</code> is set with <code>HYLE_P2P__ADDRESS=\"127.0.0.1:4321\"</code> (note the double __ for the dot).</p>"},{"location":"reference/node/","title":"Community validators","text":""},{"location":"reference/node/#community-validators","title":"Community validators","text":"<p>We\u2019re not actively expanding validator capacity at the moment, but feel free to leave your contact information: we\u2019ll definitely reach out when new opportunities arise.</p> <p>Let's get in touch</p>"},{"location":"reference/supported-proving-schemes/","title":"Supported proving schemes","text":""},{"location":"reference/supported-proving-schemes/#supported-proving-schemes","title":"Supported proving schemes","text":"<p>Clone a template or write your own program to get started with app writing.</p> Proving scheme Verifier Program ID Example app Noir noir Verification key. check_secret Risc0 risc0 Image ID without a prefix. ex. 0x123 becomes 123. eZKasino SP1 sp1 Verification key. Faucet"},{"location":"reference/supported-proving-schemes/#noir","title":"Noir","text":"<p>Because Noir is a circuit-based ZK-language, you have to define the maximum size of the state at the contract creation. For simplicity, we recommend keeping Noir for stateless contracts:</p> <ul> <li>A stateless contract in Noir for private inputs and the logic linked to them.</li> <li>A stateful contract in Rust using Risc0 or SP1 to store the private state onchain.</li> </ul> <p>Proof composition allows you to leverage the privacy of Noir and ease of use of zkVMs.</p>"},{"location":"resources/","title":"\ud83d\udcda Resources","text":""},{"location":"resources/#resources","title":"\ud83d\udcda Resources","text":"<ul> <li> <p> Roadmap</p> <p>Our upcoming launches.</p> <p> Roadmap</p> </li> <li> <p> Release notes</p> <p>See all release notes and migration guides in one place.</p> <p> Release notes</p> </li> <li> <p> Contribute</p> <p>Contribute to Hyli through hackathons and grants.</p> <p> Grants</p> </li> <li> <p> Partnerships</p> <p>Let's work together.</p> <p> Partnerships</p> </li> <li> <p> Glossary</p> <p>Understand our vocabulary</p> <p> Glossary</p> </li> <li> <p> Find us</p> <p>Find us on social media.</p> <p> Find us</p> </li> </ul>"},{"location":"resources/find-us/","title":"Find us","text":""},{"location":"resources/find-us/#useful-links","title":"Useful links","text":"<ul> <li> Node</li> <li> Example contracts</li> <li> Website</li> <li> Hyli blog</li> </ul>"},{"location":"resources/find-us/#talk-about-us","title":"Talk about us","text":"<ul> <li>Media hub</li> <li>Visual assets</li> </ul>"},{"location":"resources/find-us/#contact-us","title":"Contact us","text":"<p>Reach out to the team for more information:</p>  Github  Twitter  Farcaster  LinkedIn  Youtube  Telegram Hyli @hyli_org @Hyli Hyli @Hyli Hyli"},{"location":"resources/glossary/","title":"Glossary","text":""},{"location":"resources/glossary/#glossary","title":"Glossary","text":"Term Definition Related concept page base state The state of an app before an operation occurs. Transactions blob A piece of provable information that is sent to Hyli. Apps blob transaction A transaction including a provable blob, used for sequencing. Pipelined proving cross-contract composition The ability to use and verify a contract's proofs in other contracts. Proof composition operation Something that happens on an unchained app. An operation includes two transactions: a blob transaction and a proof transaction. Transactions proof composition The process of combining multiple zero-knowledge proofs into a single proof, enabling efficient verification and interoperability across different proving systems. Proof composition proof transaction A transaction including a proof of a previously-submitted blob, used for verification and settlement. Transactions proof verification The act by which Hyli verifies submitted proofs before settling them onchain. Transactions timeout A time window after which, if no proof transaction has been submitted, an operation fails. Pipelined proving transaction A part of an operation that gets sent to Hyli. There are two types of transactions: blob transactions and proof transactions. Transactions"},{"location":"resources/grants/","title":"Contribute to Hyli","text":""},{"location":"resources/grants/#contribute-to-hyli","title":"Contribute to Hyli","text":""},{"location":"resources/grants/#contribution-opportunities","title":"Contribution opportunities","text":"<p>You can contribute to Hyli in several ways. All our code is open source and you can create issues and submit PRs.</p> <p>You can also check out our Careers page for longer-term opportunities.</p>"},{"location":"resources/grants/#grant-program","title":"Grant program","text":"<p>Hyli has a grant program supporting developers who want to explore programmable cryptography and our product.</p>"},{"location":"resources/grants/#what-are-our-grants-like","title":"What are our grants like?","text":"<ul> <li>You apply with an original idea or an idea from the list on our repo.</li> <li>We fund your project. You get some money upfront, so you can build without financial worries, and the rest upon completion of the project.</li> <li>You meet regularly with our CEO for guidance and to help you refine your ideas.</li> <li>You are in a Telegram group with our other grantees to share ideas and solutions.</li> <li>Our tech team supports you via Telegram and in meetings.</li> <li>Our business team helps you showcase your idea through external speaking opportunities, co-marketing, and other assets.</li> </ul> <p>To read more, see our grant ideas and pas grants, and apply, please go to our Grants page on the main Hyli repository. If you represent an organization, we'd love to discuss co-grants ideas.</p> <p>For questions that aren't answered on the Grants page, reach out in our Telegram group.</p>"},{"location":"resources/partnerships/","title":"Partnerships","text":""},{"location":"resources/partnerships/#partnerships","title":"Partnerships","text":"<p>We are always open to technical and product discussions with potential partners!</p> <p>Let's get in touch</p>"},{"location":"resources/partnerships/#prover-network-zkvm","title":"Prover network / zkVM","text":"<p>We need proving power, you have it.</p> <p>The usual partnership: we integrate your zkVM or prover stack as a client, providing proof generation workloads as part of our settlement and verification pipeline.</p> <p>Read more: Proof generation and submission</p>"},{"location":"resources/partnerships/#raas-rollup-as-a-service","title":"RaaS (Rollup as a service)","text":"<p>When you integrate us as providers, your clients get:</p> <ul> <li>Ultra-fast finality via our high-throughput DA layer and shared sequencing</li> <li>Native composability across the entire Hyli ecosystem, regardless of the proof system used</li> <li>The ability to offer your clients seamless deployment of vApps into production</li> <li>Significant reduction in proof-generation latency, allowing for near-instant settlement cycles</li> </ul>"},{"location":"resources/partnerships/#zk-hardware","title":"ZK hardware","text":"<p>Your hardware can accelerate proof generation for Hyli-based rollups and applications. We are actively exploring hardware partnerships to push latency and efficiency boundaries even further.</p>"},{"location":"resources/partnerships/#applications","title":"Applications","text":"<p>With Hyli, adding verifiable computation is straightforward: use Rust, integrate a zkVM, and deploy. We're particularly interested in supporting applications around DeFi, identity, gaming, payments, AI, zkML, and voting.</p> <p>Thanks to native signature support and flexible zkVM abstraction, your app benefits from full onchain verifiability while retaining a familiar developer experience.</p> <p>Of course, our entire docs are also here for you!</p>"},{"location":"resources/partnerships/#validator-node-operator","title":"Validator / node operator","text":"<p>See community validators.</p> <p>Let's get in touch</p>"},{"location":"resources/release-notes/","title":"Release notes","text":""},{"location":"resources/release-notes/#release-notes","title":"Release notes","text":"<p>Read our full changelogs on GitHub or the short versions in our Telegram group.</p>"},{"location":"resources/release-notes/#2025-02-24-v0120","title":"2025-02-24 \u2212 v0.12.0","text":"<p>\ud83d\uddde\ufe0f Our news:</p> <ul> <li>All examples have been updated to v0.11.0</li> <li>We\u2019ve added Metamask authentication to our demo AMM, Hyleoof. We\u2019re looking forward to making the demo fully public!</li> </ul> <p>\ud83d\udca5 Breaking changes:</p> <p>We heard your feedback on our frequent breaking changes. Going forward, we\u2019ll be making fewer releases, relying instead on <code>rc</code> versions, so that breaking changes are batched.</p> <ul> <li>Contract input now uses state instead of state digest, which simplifies the API.</li> <li>SP1 verifier is now a separate feature: this drastically shortens build time if you\u2019re not using it.</li> <li>We\u2019ve improved the general structure of apps.</li> </ul> <p>\u2728 New features:</p> <ul> <li>We have a JS SDK now!</li> </ul> <p>\ud83d\ude85 Improvements:</p> <ul> <li>Added caching for computed hash, which doubles performance in heavy load situations</li> <li>Other big performance improvements for in-memory storage</li> </ul> <p>\ud83d\udee0\ufe0f No longer broken:</p> <ul> <li>Added missing data proposal hashes in blocks</li> <li>Fixed blob proof output index logic at settlement stage</li> </ul> <p>\ud83d\udcda Documentation:</p> <ul> <li>Added explanations to our proof composition concept page</li> </ul>"},{"location":"resources/release-notes/#2025-02-14-v0110","title":"2025-02-14 \u2212 v0.11.0","text":"<p>\u2728 New features:</p> <ul> <li>Added Mempool status event <code>data proposal created</code></li> <li>When a parent transaction times out, the timeout window for the child transactions is reset</li> </ul> <p>\ud83d\ude85 Improvements:</p> <ul> <li>Bumped risc0 from 1.2.2 to 1.2.3 and sp1 from 4.0.1 to 4.1.1</li> <li>Improved several logs, making them more specific or adding context to them, especially on error logs</li> <li>Improved storage to make it more compact</li> </ul> <p>\ud83d\udee0\ufe0f No longer broken:</p> <ul> <li>The Mempool status event <code>wait dissemination</code> now works for the first data proposal (genesis)</li> <li>The indexer client now gets blobs\u2019 endpoints</li> <li>Fixed the input encoding for the bonsai runner</li> </ul> <p>\ud83d\udcda Documentation:</p> <ul> <li>Revamped homepage and in-docs navigation</li> <li>Made some improvements for clarity to our pipelined proving concept page</li> <li>Added a page on proof generation and submission</li> </ul>"},{"location":"resources/release-notes/#2025-02-07-v0100","title":"2025-02-07 \u2212 v0.10.0","text":"<p>\ud83d\udca5 Breaking change: we\u2019ve replaced our serialization standard, bincode, with borsh. Encoding BlobData from JS didn\u2019t work properly with bincode: borsh offers better support and opens new possibilities!</p> <p>\u2728 New features:</p> <ul> <li>Introduced an indexer endpoint that adds events to BlobTXs: if your transaction didn\u2019t settle, you can now debug its flow much more easily!</li> <li>Introduced fees in ConsensusProposal. This has no external impact at this time.</li> <li>Added Mempool status event <code>waiting_dissemination</code></li> </ul> <p>\ud83d\udee0\ufe0f No longer broken:</p> <ul> <li>Hyllar Indexer now computes the correct caller in proof composition cases.</li> <li>Fixed a bug where the client couldn\u2019t close the websocket.</li> </ul>"},{"location":"resources/release-notes/#2025-02-03-v090","title":"2025-02-03 \u2212 v0.9.0","text":"<p>\ud83d\udca5 Breaking changes:</p> <ul> <li>Added transactions context (block, timestamp, \u2026) to proofs for more flexibility</li> </ul> <p>\u2728 New features:</p> <ul> <li>You can now start a node with an indexer and postgres database simply with <code>cargo run -- --pg</code></li> <li>Added an endpoint for contract registration</li> </ul> <p>\ud83d\ude85 Improvements:</p> <ul> <li>Updated risc0 to 1.2.2</li> <li>Made logging less spammy and more informative (incl. logging timeouts as info)</li> <li>Improved the transaction builder tool in the SDK</li> </ul> <p>\ud83d\udee0\ufe0f No longer broken:</p> <ul> <li>Contract state indexers are now fully saved upon restart</li> <li>Staking contracts now check that there is a <code>transfer</code> blob</li> <li>The Rust version enforced in cargo is less restrictive</li> </ul> <p>\ud83d\udcda Documentation:</p> <ul> <li>Updated our examples so they work with 0.9.0!</li> <li>Added OpenAPI documentation on contract state indexers</li> <li>Added a swagger for the node and its indexer</li> </ul> <p>Quick note: release notes will be published on Fridays instead of Mondays from now on. See you in just a few days!</p>"},{"location":"resources/release-notes/#2025-01-27-v080","title":"2025-01-27 \u2212 v0.8.0","text":"<p>\ud83d\udca5 Breaking changes:</p> <ul> <li>Hyle-contracts: Merged the contracts \u2018metadata\u2019 feature into \u2018client\u2019</li> <li>There are no more <code>RegisterContract</code> transactions: contracts are now registered with <code>BlobTransactions</code>, like everything else.</li> <li>Contract registration has been reworked using proof outputs; we introduced UUID contract names (see uuid-tld for an example).</li> <li>Removed <code>hyled</code> and <code>hyrun</code>. If you were using them, check out our SDK instead.</li> </ul> <p>\u2728New features:</p> <ul> <li>You can now settle transactions that have a proof of failure before they timeout</li> <li>Made progress on the implementation of our consensus</li> </ul> <p>\ud83d\ude85 Improvements:</p> <ul> <li>We now enforce a recent Rust version to avoid errors.</li> </ul> <p>\ud83d\udee0\ufe0f No longer broken:</p> <ul> <li>Bug fixes include Dockerfile, environment variables, and identities.</li> </ul> <p>\ud83d\udcda Documentation:</p> <ul> <li>Our SDK has a README now!</li> </ul> <p>Read the full changelog on GitHub.</p>"},{"location":"resources/release-notes/#2025-01-21-v071-v072","title":"2025-01-21 \u2212 v0.7.1 &amp; v0.7.2","text":"<p>Small patches for our SDK.</p> <p>Read release notes for v0.7.1 and v0.7.2; see new SDK readme for more info.</p>"},{"location":"resources/release-notes/#2025-01-20-v070","title":"2025-01-20 \u2212 v0.7.0","text":"<p>\ud83d\udca5 Breaking changes:</p> <ul> <li>We completely rewrote the dependencies for the SDK.</li> </ul> <p>\u2728 New features;</p> <ul> <li>Adding support of native verifiers. Verify hash signatures, TEE executions without needing a ZK proof! Currently supported: sha3_256 &amp; BLST signatures.</li> <li>You can now use <code>tx hash</code> inside contracts</li> </ul> <p>\ud83d\ude85 Improvements:</p> <ul> <li>Several performance improvements following our latest loadtest</li> <li>Reduce log verbosity and frequency</li> <li>Dependencies: updated risc0-zkvm to 1.2.1, sp1-sdk to 4.0.0</li> </ul> <p>\ud83d\udee0\ufe0f No longer broken:</p> <ul> <li>Loads of bug fixes \u2212 check the full release to know more.</li> </ul> <p>\ud83d\udcda Documentation:</p> <ul> <li>Transactions on Hyli</li> <li>Identity management</li> </ul> <p>Read the full changelog on GitHub and receive future release notes in our Telegram group.</p>"},{"location":"resources/release-notes/#2025-01-13-v060","title":"2025-01-13 \u2212 v0.6.0","text":"<p>\u2728 New features:</p> <ul> <li>Added the SP1 prover to the client SDK.</li> </ul> <p>\ud83d\ude85 Improvements:</p> <ul> <li>Upgraded to SP1 4.0.0-rc8.</li> </ul> <p>\ud83d\udee0\ufe0f No longer broken:</p> <ul> <li>Fixed the default configurations.</li> <li>Fixed loading state when restarting a node.</li> </ul> <p>\ud83d\udcda Documentation:</p> <ul> <li>Rewrote our Quickstart guide.</li> </ul> <p>Read the full changelog on GitHub and receive future release notes in our Telegram group.</p>"},{"location":"resources/roadmap/","title":"Roadmap","text":""},{"location":"resources/roadmap/#testnet","title":"Testnet","text":"<p>Our private testnet is live and can be accessed with invite codes. Invite codes will be shared on social media channels.</p> <p>Stay tuned for updates or ask specific questions in our Telegram group.</p> <p>While we\u2019re working, you can get hands-on right now: create your first app on Hyli!</p>"},{"location":"resources/roadmap/#proving-schemes","title":"Proving schemes","text":"<p>Check the list of the proving schemes we currently support and the ones we'll work on next.</p>"},{"location":"tooling/","title":"\ud83e\uddf0 Tooling","text":""},{"location":"tooling/#tooling","title":"Tooling","text":"<p>Here, you'll find our resources about Hyli's tooling.</p> <ul> <li> <p> Explorer</p> <p>Use the Hyli explorer.</p> <p> Read more</p> </li> <li> <p> Explorer</p> <p>Use the Hyli wallet.</p> <p> Read more</p> </li> <li> <p> SDK</p> <p>Use the helper functions in our contract SDK.</p> <p> Read more</p> </li> <li> <p> API</p> <p>Explore our API.</p> <p> Read more</p> </li> </ul>"},{"location":"tooling/api/","title":"API","text":""},{"location":"tooling/api/#api","title":"API","text":"<p>Hyli's API allows you to interact with its core components.</p>"},{"location":"tooling/api/#openapi-documentation","title":"OpenAPI documentation","text":"<p>To explore available endpoints and understand the API structure:</p> <ol> <li>Run a local node.</li> <li>Open http://localhost:4321/swagger-ui/.</li> </ol> <p>Or visit https://indexer.devnet.hyli.org/swagger-ui/ for an indexer-only api documentation.</p>"},{"location":"tooling/api/#sdk-implementations","title":"SDK implementations","text":"<p>We currently support Rust and JS environments.</p> Language Repository / Package JS hyle on npm Rust hyle client sdk on docs.rs"},{"location":"tooling/explorer/","title":"Explorer","text":""},{"location":"tooling/explorer/#explorer","title":"Explorer","text":"<p>Open the explorer</p>"},{"location":"tooling/sdk/","title":"SDK","text":""},{"location":"tooling/sdk/#sdk","title":"SDK","text":"<p>Our contract SDK includes helper functions for building an app on Hyli.</p> <p>Read the doc on docs.rs.</p>"},{"location":"tooling/wallet/","title":"Using the Hyli wallet","text":""},{"location":"tooling/wallet/#using-the-hyli-wallet","title":"Using the Hyli wallet","text":"<p>On most blockchains, your identity is your wallet address. On Hyli, identity is a flexible set of credentials verified by a smart contract.</p> <p>On Hyli, any smart contract can function as a verifiable proof of identity. This enables fine-grained access control and varied authentication mechanisms where each app can rely on the most appropriate form of identity verification: OIDC, password-based, and zkPassport are all valid sources of ID that are relevant in different contexts.</p> <p>While extremely flexible, identity management on Hyli can create some complexity for users and developers. So we created the Hyli wallet as an identity hub to offer a unified experience with all Hyli apps.</p> <p>The Hyli Wallet acts as a gateway to onchain identity. It lets users:</p> <ul> <li>register multiple authentication methods,</li> <li>generate app-specific session keys,</li> <li>authenticate without exposing private data.</li> </ul> <p>This creates a unified identity layer for seamless interaction across apps on Hyli.</p>"},{"location":"tooling/wallet/#user-experience-with-the-hyli-wallet","title":"User experience with the Hyli wallet","text":""},{"location":"tooling/wallet/#create-a-wallet","title":"Create a wallet","text":"<p>Creating the Hyli wallet is done, as with everything else on Hyli, by sending a transaction. The transaction includes two blobs:</p> <ol> <li>A <code>CheckSecret</code> blob takes the user\u2019s password as private input and asserts that the hash is correct;</li> <li>A <code>registerAccount</code> blob verifies and stores the user\u2019s Hyli identity, <code>max@wallet</code>, in its state.</li> </ol> <p>The CheckSecret contract is written in Noir; see the source code on GitHub.</p>"},{"location":"tooling/wallet/#create-a-session-key","title":"Create a session key","text":"<p>The user can create a session key on any app. A session key includes a public key and a private key.</p>"},{"location":"tooling/wallet/#register-the-session-key","title":"Register the session key","text":"<p>The user registers their session key in a new transaction, which, again, includes two blobs:</p> <ol> <li>A <code>CheckSecret</code> blob makes sure that the password is correct, meaning that the user is correctly authenticated;</li> <li>A <code>registerSessionKey</code> blob registers the public key as a session key associated with the user\u2019s account and adds the new contract to the allowlist.</li> </ol> <p>Now, the session key is linked to the user\u2019s wallet. This means that the user can use their wallet to interact with the allowlisted contract.</p>"},{"location":"tooling/wallet/#use-the-session-key-for-a-future-action","title":"Use the session key for a future action","text":"<p>When interacting with the allowlisted contract, the transaction will include three blobs:</p> <ol> <li>A blob to verify the user\u2019s signature using the private key. The blob signs a timestamp and is used to update the session key\u2019s nonce.</li> <li>A blob to verify the session key, asserting that the key used for the signature in the first blob is associated with the user\u2019s account.</li> <li>A blob for the transfer itself.</li> </ol>"},{"location":"tooling/wallet/#why-use-the-hyli-wallet","title":"Why use the Hyli wallet?","text":"<p>With this architecture, interacting with a smart contract does not require any private input in the zkVM. The signature is verified natively without requiring the generation of a zero-knowledge proof for this blob.</p> <p>The two other blobs don\u2019t require authentication, as the authentication blob works for the entire transaction thanks to Hyli\u2019s native proof composition.</p> <p>This has the added benefit of avoiding timeouts. Since there are no private inputs, anyone can verify every blob in the transaction without worrying too much about privacy, and there is no bottleneck in verification times, as there could be if there were invalid data in a private input. Apps can externalize proving without worrying about security.</p>"},{"location":"tooling/wallet/#building-with-the-hyli-wallet","title":"Building with the Hyli wallet","text":""},{"location":"tooling/wallet/#clone-the-repository","title":"Clone the repository","text":"<p>Clone the Hyli wallet repository.</p>"},{"location":"tooling/wallet/#install","title":"Install","text":"<pre><code>npm install hyli-wallet\n# or\nyarn add hyli-wallet\n</code></pre> <p>Note the following peer dependencies:</p> <pre><code>{\n    \"hyli-check-secret\": \"^0.3.2\",\n    \"react\": \"^19.1.0\",\n    \"react-dom\": \"^19.1.0\",\n    \"react-router-dom\": \"^7.5.0\"\n}\n</code></pre>"},{"location":"tooling/wallet/#basic-usage","title":"Basic Usage","text":""},{"location":"tooling/wallet/#wrap-your-application","title":"Wrap your application","text":"<p>First, wrap your application with the <code>WalletProvider</code>:</p> <pre><code>import { WalletProvider } from \"hyli-wallet\";\n\nfunction App() {\n    return (\n        &lt;WalletProvider\n            config={{\n                nodeBaseUrl: \"NODE_BASE_URL\",\n                walletServerBaseUrl: \"WALLET_SERVER_URL\",\n                applicationWsUrl: \"WEBSOCKET_URL\",\n            }}\n            // Optional: session key config\n            sessionKeyConfig={{\n                duration: 24 * 60 * 60 * 1000, // Session key duration in ms (default: 72h)\n                whitelist: [], // Required: contracts allowed for session key\n            }}\n            // Optional: global wallet event handler\n            onWalletEvent={(event) =&gt; {\n                console.log(\"Wallet event:\", event);\n            }}\n            // Optional: global wallet error handler\n            onError={(error) =&gt; {\n                console.error(\"Wallet error:\", error);\n            }}\n        &gt;\n            &lt;YourApp /&gt;\n        &lt;/WalletProvider&gt;\n    );\n}\n</code></pre>"},{"location":"tooling/wallet/#use-the-wallet-component","title":"Use the wallet component","text":"<pre><code>import { HyliWallet } from \"hyli-wallet\";\n\nfunction YourComponent() {\n    return (\n        &lt;HyliWallet\n            providers={[\"password\", \"google\", \"github\"]} // Optional: specify auth providers\n        /&gt;\n    );\n}\n</code></pre>"},{"location":"tooling/wallet/#use-the-wallet-hook","title":"Use the Wallet Hook","text":"<p>The <code>useWallet</code> hook provides access to wallet functionality.</p> <pre><code>import { useWallet } from \"hyli-wallet\";\n\nfunction WalletFeatures() {\n    const {\n        wallet, // Current wallet state\n        isLoading,\n        error,\n        login, // Login function\n        registerAccount, // Create new account\n        logout, // Logout function\n        registerSessionKey, // Create new session key\n        removeSessionKey, // Remove existing session key\n        signMessageWithSessionKey, // Sign a message with the current session key\n    } = useWallet();\n\n    return (\n        &lt;div&gt;\n            {wallet ? (\n                &lt;div&gt;\n                    &lt;p&gt;Welcome, {wallet.username}&lt;/p&gt;\n                    &lt;p&gt;Balance: {balance} HYLLAR&lt;/p&gt;\n                    &lt;button onClick={logout}&gt;Logout&lt;/button&gt;\n                &lt;/div&gt;\n            ) : (\n                &lt;p&gt;Please connect your wallet&lt;/p&gt;\n            )}\n        &lt;/div&gt;\n    );\n}\n</code></pre>"},{"location":"tooling/wallet/#session-key-management","title":"Session key management","text":"<p>Find a full implementation of session keys in SessionKeys.tsx.</p>"},{"location":"tooling/wallet/#creating-a-session-key","title":"Creating a session key","text":"<p>Session keys allow for delegated transaction signing. Here's how to create one:</p> <pre><code>import { useWallet } from 'hyli-wallet';\n\nconst { wallet, registerSessionKey } = useWallet();\n\n// Create a session key that expires in 7 days\nconst expiration = Date.now() + (7 * 24 * 60 * 60 * 1000);\n\nconst { sessionKey } = await registerSessionKey(\n  'your_password',\n  expiration,\n  ['hyllar'] // contracts whitelist\n  (txHash: string, type: string) =&gt; {\n     if (type === 'blob') {\n       console.log('Verifying identity...');\n       console.log(\"transaction hash: \", txHash);\n     } else if (type === 'proof') {\n       console.log('Proof sent, waiting for confirmation...');\n       console.log(\"transaction hash: \", txHash);\n     }\n   }\n);\n\n// The sessionKey object contains:\nconsole.log(sessionKey.publicKey);  // The public key to identify the session\nconsole.log(sessionKey.privateKey); // The private key to sign transactions\n// Note that this session key will also be stored in the wallet object\n</code></pre>"},{"location":"tooling/wallet/#signing-a-transaction-with-a-session-key","title":"Signing a transaction with a session key","text":"<p>Once you have a session key, you can use it to send transactions.</p> <pre><code>import { useWallet } from \"hyli-wallet\";\nimport { nodeService } from \"your-services\";\n\nconst { wallet, createIdentityBlobs } = useWallet();\n\n// Create identity blobs using the latest created session key, stored in  `wallet` object\nconst [blob0, blob1] = createIdentityBlobs();\n\n// Create and send the transaction\nconst blobTx = {\n    identity: wallet.address,\n    blobs: [blob0, blob1],\n};\n// blob0 is the secp256k1 blob containing the signature done with the wallet's session keu\n// blob1 is the hyli-wallet contract that verifies that the session key is valid\n\nconst txHash = await nodeService.client.sendBlobTx(blobTx);\nconsole.log(\"Transaction sent:\", txHash);\n</code></pre>"},{"location":"tooling/wallet/#removing-a-session-key","title":"Removing a session key","text":"<p>When a session key is no longer needed, you can remove it:</p> <pre><code>import { useWallet } from \"hyli-wallet\";\n\nconst { removeSessionKey } = useWallet();\n\n// Remove the session key using the wallet password\nawait removeSessionKey(\"your_password\", \"session_key_public_key\");\n</code></pre>"},{"location":"tooling/wallet/#signing-arbitrary-messages-with-a-session-key","title":"Signing arbitrary messages with a session key","text":"<p>You can sign any message using the current session key.</p> <pre><code>import { useWallet } from \"hyli-wallet\";\n\nconst { signMessageWithSessionKey } = useWallet();\n\nconst message = \"Hello, Hyli!\";\nconst { hash, signature } = signMessageWithSessionKey(message);\n\nconsole.log(\"Message hash (Uint8Array):\", hash);\nconsole.log(\"Signature (Uint8Array):\", signature);\n</code></pre> <ul> <li><code>signMessageWithSessionKey(message: string)</code> will throw if there is no session key in the wallet.</li> <li>The raw hash and signature return as <code>Uint8Array</code>.</li> </ul>"},{"location":"tooling/wallet/#websocket-integration","title":"WebSocket integration","text":"<p>Real-time updates for transactions and wallet events:</p> <pre><code>function TransactionMonitor() {\n    useWebSocketConnection(wallet?.address, (event) =&gt; {\n        if (event.tx.status === \"Success\") {\n            // Handle successful transaction\n            fetchBalance();\n        }\n    });\n}\n</code></pre>"},{"location":"tooling/wallet/#customizing-the-user-interface","title":"Customizing the user interface","text":"<p>You can customize the connect button by providing a render prop:</p> <pre><code>&lt;HyliWallet\n    button={({ onClick }) =&gt; (\n        &lt;button className=\"custom-button\" onClick={onClick}&gt;\n            Connect to Wallet\n        &lt;/button&gt;\n    )}\n/&gt;\n</code></pre>"},{"location":"tooling/wallet/#web-component","title":"Web component","text":"<p>The library also provides a web component for non-React applications:</p> <pre><code>&lt;script type=\"module\" src=\"path/to/hyli-wallet/dist/hyli-wallet.es.js\"&gt;&lt;/script&gt;\n&lt;hyli-wallet providers=\"password,google\"&gt;&lt;/hyli-wallet&gt;\n</code></pre>"}]}