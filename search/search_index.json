{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":""},{"location":"#home","title":"Home","text":"<p>Hyli is the new proof-powered L1 to build the next generation of apps.</p> <p>With Hyli, developers can build fast, composable, and verifiable apps without dealing with the usual pains of blockchain.</p> <p>On Hyli, instead of executing transactions onchain, you run your app logic anywhere off-chain, in Rust, Noir, or even multiple languages at once. You only need to send a proof for onchain settlement. With this model, your app benefits from the Web2 user experience and the security of Web3.</p>"},{"location":"#navigation","title":"Navigation","text":"<ul> <li> <p> Hyli guide</p> <p>Your entry point to understanding Hyli, with minimal code.</p> <p> Primer</p> </li> <li> <p> Quickstart</p> <p>Get started with Hyli in just a few minutes with a step-by-step annotated quickstart.</p> <p> Quickstart</p> </li> <li> <p> Concepts</p> <p>Hyli-specific concepts and Hyli's spin on industry classics explained in detail.</p> <p> Concepts</p> </li> <li> <p> Tooling</p> <p>Hyli tooling to improve your building experience.</p> <p> Tooling</p> </li> </ul> <p>Reach out on Telegram or open an issue if you need assistance or wish to provide feedback on the documentation: we're always looking to improve.</p>"},{"location":"#how-hyli-works","title":"How Hyli works","text":"<p>Here\u2019s what happens when you use Hyli\u2019s next-generation Layer 1:</p> <ol> <li>Write your app: Write a contract and define how state changes should happen. You'll run this logic wherever you want. Write in Rust or Noir and use any proving scheme we support. You can also leverage our native digital signature verifiers.</li> <li>Send a blob transaction: Send a provable blob to Hyli, stating what final state you expect after the transaction. Hyli will sequence the transaction immediately: you get a timestamp and a guaranteed place in the block. Read more about pipelined proving.</li> <li>Generate and submit the proof: Generate proofs wherever you want: client-side or in a browser, with or without a partner proving network. When the proofs for your transaction are ready, send them to Hyli in a proof transaction that references the previous blob transaction.</li> <li>Finality: Hyli validators receive the transaction and verify the proofs natively, without the limitations of a bulky virtual machine. If the proofs are valid, Hyli finalizes the transaction and updates your contract's onchain state root. You're good to go!</li> </ol> <p></p>"},{"location":"#what-you-get-with-hyli","title":"What you get with Hyli","text":"<p>Hyli is built for speed, flexibility, and seamless blockchain integration.</p> <p>With our model, you get:</p> <ul> <li>You skip onchain execution entirely.</li> <li>You can use the Hyli wallet for identity abstraction.</li> <li>You choose your proving system (Noir, RISC0, SP1\u2026).</li> <li>You generate your proofs wherever you'd like (client-side, in a server, through a proving network\u2026).</li> <li>You can compose proofs across contracts and languages.</li> <li>You benefit from the state-of-the-art Autobahn consensus.</li> <li>You get Web2-like speed with Web3 security.</li> </ul> <p>Read more about how Hyli compares to legacy blockchains.</p>"},{"location":"#useful-links","title":"Useful links","text":"<ul> <li> Rust node</li> <li> Example contracts</li> <li> Website</li> <li> Hyli blog</li> </ul> <p>Vibe coders, use our LLMs.txt file!</p>"},{"location":"#lets-talk","title":"Let's talk","text":"<p>Reach out to the team for more information:</p>  Github  Twitter  Farcaster  LinkedIn  Youtube  Telegram Hyli @hyli_org @Hyli Hyli @Hyli Hyli"},{"location":"concepts/","title":"\ud83d\udca1 Concepts","text":""},{"location":"concepts/#concepts","title":"Concepts","text":"<p>Welcome to the developer documentation for Hyli.</p> <p>This section includes general documentation topics. You can also refer to our Getting Started step-by-step guide.</p>"},{"location":"concepts/#hyli-specific-docs-on-industry-concepts","title":"Hyli-specific docs on industry concepts","text":"<ul> <li> <p> Apps</p> <p>Most app information stays off-chain.</p> <p> Read more</p> </li> <li> <p> Transactions</p> <p>Understand blob transactions and proof transactions.</p> <p> Read more</p> </li> <li> <p> Proof generation</p> <p>Learn how to prove your blobs for Hyli.</p> <p> Read more</p> </li> <li> <p> Identity</p> <p>Any app can be an identity on Hyli.</p> <p> Read more</p> </li> </ul>"},{"location":"concepts/#hyli-specific-concepts","title":"Hyli-specific concepts","text":"<ul> <li> <p> Proof composition</p> <p>Compose several proof systems and manage cross-contract composition seamlessly.</p> <p> Read more</p> </li> <li> <p> Pipelined proving</p> <p>Separate sequencing and settlement and remove proving times from your app's critical path.</p> <p> Read more</p> </li> </ul>"},{"location":"concepts/#more","title":"More","text":"<ul> <li> <p> Hyli vs. vintage blockchains</p> <p>Learn the main differences between Hyli and traditional blockchains.</p> <p> Read more</p> </li> <li> <p> Consensus</p> <p>Learn about our consensus algorithm, based on Autobahn.</p> <p> Read more</p> </li> </ul>"},{"location":"concepts/apps/","title":"Apps on Hyli","text":""},{"location":"concepts/apps/#apps-on-hyli","title":"Apps on Hyli","text":"<p>Hyli is a fully programmable blockchain designed for efficient data storage. Hyli only keeps the essential information needed to validate app proofs, ensuring that apps are lightweight and performant.</p> <p>Unlike traditional blockchains, which store all app data onchain, Hyli separates execution data (managed offchain by each application) from onchain data, which can be retrieved via our ABI.</p>"},{"location":"concepts/apps/#onchain-app-data","title":"Onchain app data","text":"<p>Hyli apps store the following data onchain:</p> <ul> <li>Name: the unique identifier for the contract</li> <li>Verifier: the proof system used (e.g., \"risc0\")</li> <li>Program ID: the unique identifier for the program within that proof system</li> <li>State digest: current state commitment of the contract</li> </ul>"},{"location":"concepts/apps/#explanation-of-the-contract-fields","title":"Explanation of the contract fields","text":""},{"location":"concepts/apps/#name","title":"Name","text":"<p>The contract name must be unique.</p>"},{"location":"concepts/apps/#verifier-and-program-id","title":"Verifier and program ID","text":"<p>Apps on Hyli rely on a pairing of a zero-knowledge proof scheme (verifier) and a program identifier. Together, these components validate contract proofs.</p> <p>See the verifier scheme for each supported proving scheme in this reference page.</p>"},{"location":"concepts/apps/#state-digest","title":"State digest","text":"<p>The state digest represents the contract's current state commitment. It allows Hyli to guarantee its integrity. It can take any form as long as it fulfills this purpose.</p> <p>The state digest can be expressed as a hash or even a serialization of the state if it's small enough.</p>"},{"location":"concepts/apps/#smart-contract-abi","title":"Smart contract ABI","text":"<p>All inputs in Hyli apps must be known at proof generation time. This includes elements like the <code>tx_hash</code> which are typically available only at execution time on other blockchains.</p> <p>Here is the Rust structure specifying the output of a Hyli app:</p> <pre><code>pub struct HyleOutput {\n    pub version: u32,\n    pub initial_state: StateDigest,\n    pub next_state: StateDigest,\n    pub identity: Identity,\n    pub index: BlobIndex,\n    pub blobs: Vec&lt;u8&gt;,\n    pub tx_hash: TxHash,\n    pub success: bool,\n    pub tx_ctx: Option&lt;TxContext&gt;,\n    pub registered_contracts: Vec&lt;RegisterContractEffect&gt;,\n    pub program_outputs: Vec&lt;u8&gt;, \n}\n</code></pre>"},{"location":"concepts/apps/#version","title":"Version","text":"<p>For now, <code>version</code> should always be set to 1.</p>"},{"location":"concepts/apps/#initial-state-and-next-state","title":"Initial state and next state","text":"<p>These fields define state transitions.</p> <ul> <li><code>initial_state</code>: must match the onchain <code>state_digest</code> before the transaction. If they don't match, the state transition is invalid.</li> <li><code>next_state</code>: Represents the new onchain <code>state_digest</code> after the transaction.</li> </ul> <p>In the future, <code>state_digest</code> size will be limited and fees will depend on proof size (which is affected by the digest's size). Keep them small!</p>"},{"location":"concepts/apps/#identity","title":"Identity","text":"<p>Info</p> <p>Read our identity documentation for details.</p> <p>Identity consists of:</p> <ol> <li>An identifier;</li> <li>The name of the contract that the proof was generated for.</li> </ol> <p>Example</p> <p>A contract verifying Ethereum EOAs might have an identity like <code>0x1234...5678@eth_eoa</code> where the first part matches a regular Ethereum address and <code>eth_eoa</code> is the name of the contract.</p> <p>For simplicity, we recommend using the pre-built Hyli wallet.</p>"},{"location":"concepts/apps/#blob-index-and-blobs","title":"Blob index and blobs","text":"<p>Each blob transaction includes multiple blobs:</p> <ul> <li><code>index</code> uniquely identifies a blob within a transaction.</li> <li><code>blobs</code> is a list of all blobs included in the transaction.</li> </ul>"},{"location":"concepts/apps/#tx-hash","title":"TX Hash","text":"<p><code>tx_hash</code> is the blob Transaction's hash.</p> <p>The protocol does not validate this field and <code>tx_hash</code> may be deprecated in later versions.</p>"},{"location":"concepts/apps/#success","title":"Success","text":"<p>This boolean field indicates whether the proof is for a successful or failed transactions. It can be used to prove that a transaction is invalid.</p> <p>If a proof returns <code>success = false</code>, the whole blob transaction will fail. In that case, there is no need to generate proofs for other blobs.</p>"},{"location":"concepts/apps/#transaction-context","title":"Transaction context","text":"<p>Transaction context allows the contract to know in which block (hash, height, timestamp) the blob transaction has been sequenced.</p> <p>This field is optional. If left empty, it will not be validated by Hyli or usable by the program.</p>"},{"location":"concepts/apps/#registered-contracts","title":"Registered contracts","text":"<p>A list of new contracts to register, which can be used to self-upgrade a contract.</p>"},{"location":"concepts/apps/#other-program-specific-outputs","title":"Other program-specific outputs","text":"<p>Apps can generate additional outputs as proof data. These outputs ensure data availability.</p>"},{"location":"concepts/apps/#events","title":"Events","text":"<p>Hyli does not use traditional events. Instead, it relies on blobs, which serve as containers for offchain data.</p>"},{"location":"concepts/consensus/","title":"Consensus","text":""},{"location":"concepts/consensus/#consensus","title":"Consensus","text":"<p>Autobahn is the next-generation consensus protocol that Hyli uses. It delivers high throughput and fast recovery through a novel two-layer design: parallel data lanes and BFT-based snapshot consensus.</p>"},{"location":"concepts/consensus/#the-problem-traditional-consensus-stalls","title":"The problem: traditional consensus stalls","text":"<p>Most consensus protocols today (like PBFT, HotStuff, or Tendermint) assume failure is rare and recovery is fast.</p> <p>In practice:</p> <ul> <li>Networks experience regular disruptions and latency spikes.</li> <li>Throughput is bottlenecked by leader-based message propagation.</li> <li>After a fault, most systems stall or slow down before stabilizing, a phenomenon we refer to as a \u201changover\u201d. This happens because the data in the blocks is not committed: the next block after the fault will contain all the missed transactions, making it even harder to broadcast than before the fault occurred.</li> </ul> <p>These issues create a ceiling for scalability, especially under real-world conditions.</p>"},{"location":"concepts/consensus/#the-solution-autobahn","title":"The solution: Autobahn","text":"<p>Hyli uses Autobahn, an upcoming consensus protocol that combines high throughput, a steady commit pace, and seamless recovery from network disruptions or Byzantine faults.</p> <p>The price we pay for this stability is more message deliveries, and therefore slightly higher latency, than in traditional consensus protocols. Pipelined proving allows Hyli to keep offering an ultra-fast experience.</p> <p>Autobahn combines two separate layers:</p> <ul> <li>Data dissemination through parallel \u201clanes\u201d per validator.</li> <li>Consensus finalizes a snapshot of all lanes. Thanks to the separation of the two layers, the consensus message remains fixed in size, regardless of the amount of data being finalized.</li> </ul>"},{"location":"concepts/consensus/#why-autobahn-helps-developers","title":"Why Autobahn helps developers","text":"<ul> <li>High throughput, even complex or high-volume apps</li> <li>Fast recovery even when the network blips</li> <li>Lightweight nodes that are cheaper to run and easier to scale</li> <li>Low latency if you use a rollup-centric approach, so a local node deals with the proofs before the data is broadcast to the rest of the network</li> </ul>"},{"location":"concepts/consensus/#data-dissemination-via-lanes","title":"Data dissemination via lanes","text":"<p>Each validator maintains a \u201clane,\u201d a local chain of data proposals (which would be called \u201cblocks\u201d on a legacy blockchain) that they produce and broadcast.</p> <p></p> <p>Data proposals are broadcast and certified with threshold signatures. A proof of availability is created when one-third of the validators have seen and acknowledged a block. That way, availability is guaranteed before entering consensus.</p> <p>This is good for three reasons.</p> <p>Consensus doesn\u2019t wait for data: in most protocols, validators must download and verify all the data during the consensus process. If the data is large or delayed, the consensus slows down or stops altogether. With the proof of availability on Autobahn, validators check availability before voting. This means that consensus messages are a constant size (since they don\u2019t need to include the data), so consensus stays fast.</p> <p>Consensus can settle many blocks at once: proof of availability certifies an entire chain of previous blocks. Finalizing the end of the lane means you finalize everything before it. This way, consensus can commit hundreds of blocks in a single round.</p> <p>Recovery is fast: every node is the leader of its own lane. When consensus stalls because of a faulty consensus leader, data dissemination from all the other nodes continues: catch-up is easily achieved by pulling the tip of each lane and verifying proof of availability without needing to re-run consensus on the missed blocks. This means that after faults, you have a smooth, near-instant recovery.</p>"},{"location":"concepts/consensus/#consensus-fast-finality-with-tip-cuts","title":"Consensus: fast finality with tip cuts","text":"<p>In the consensus phase, a rotating leader collects the hash and proof of availability (PoA) of the latest block in each lane. The leader doesn\u2019t need the full blocks, since availability has already been verified. It then proposes a snapshot of these lane tips, called a cut, as a way to advance the data stream progression.</p> <p></p> <p>All validators vote in a two-round Byzantine Fault Tolerant (BFT) consensus to finalize this cut. After that, all blocks before and up to that cut are considered finalized.</p> <p></p> <p>As the data has already been verified outside of the latency-critical path, the finality is fast.</p>"},{"location":"concepts/consensus/#performance","title":"Performance","text":"<p>Autobahn offers horizontal scalability: it parallelizes data dissemination through lanes, meaning that the more validators you have, the more lanes you have. In other words, bandwidth goes up with the number of validators.</p> <p>We are currently in our first testnet phase; we\u2019ll add real-life performance once this phase is over.</p> <p>We encourage you to read Sei Labs\u2019 benchmark to see their results.</p>"},{"location":"concepts/consensus/#security","title":"Security","text":"<p>Some notes on the moderl's security:</p> <ul> <li>It is safe as long as two-thirds of the validators are trustworthy.</li> <li>The proof of availability signatures are threshold-based and slashable.</li> <li>Safety and liveness are ensured even with partial asynchrony.</li> </ul>"},{"location":"concepts/consensus/#resources","title":"Resources","text":"<ul> <li>Autobahn whitepaper. All images in this page are derived from the Autobahn whitepaper.</li> <li>Commonware: Ordered Broadcast</li> <li>Sei Labs Autobahn Benchmark</li> </ul>"},{"location":"concepts/hyli-vs-vintage-blockchains/","title":"Hyli vs. vintage blockchains","text":""},{"location":"concepts/hyli-vs-vintage-blockchains/#hyli-vs-vintage-blockchains","title":"Hyli vs. vintage blockchains","text":"<p>If you're used to traditional blockchains such as Ethereum or Solana, keep these Hyli characteristics in mind.</p>"},{"location":"concepts/hyli-vs-vintage-blockchains/#no-evm-or-execution-layer","title":"No EVM or execution layer","text":"<p>Hyli does not include a Virtual Machine.</p> <p>There is no dedicated execution engine or specific programming language (like Solidity) you should use.</p> <p>Our approach is simple: onchain, we verify zero-knowledge proofs natively. Offchain, you do everything else the way you prefer. This gives you higher throughput, faster finality, and lower gas fees.</p>"},{"location":"concepts/hyli-vs-vintage-blockchains/#minimal-onchain-state","title":"Minimal onchain state","text":"<p>The network maintains proofs of state transitions rather than the entire onchain state.</p> <p>Transactions on Hyli verify and settle transitions without storing full intermediary states onchain.</p> <p>This architecture reduces storage overhead and promotes scalability while maintaining trustlessness.</p>"},{"location":"concepts/hyli-vs-vintage-blockchains/#no-wallets","title":"No wallets","text":"<p>Stop asking yourself, \"Which wallet do I use? How do I bridge?\". You don\u2019t need to worry about that with Hyli: any identity that can produce a valid proof can be integrated in your Hyli wallet.</p>"},{"location":"concepts/hyli-vs-vintage-blockchains/#every-app-is-a-rollup","title":"Every app is a rollup","text":"<p>On Hyli, there is one general-purpose blockchain, and every app is its own based ZK-rollup, removing the problems associated with fragmentation.</p> <p>An app\u2019s transactions are sequenced directly on the Hyli Layer 1. They are split into a blob transaction, which allows for pipelined proving, and a proof transaction to store the state commitment onchain.</p>"},{"location":"concepts/hyli-vs-vintage-blockchains/#privacy-is-built-in","title":"Privacy is built-in","text":"<p>Unlike Ethereum, where privacy solutions must be implemented on top of the platform, Hyli integrates privacy features natively.</p> <p>The proof is public, but your inputs don't need to be, as execution happens offchain.</p>"},{"location":"concepts/identity/","title":"Identity management","text":""},{"location":"concepts/identity/#identity-management","title":"Identity management","text":"<p>Info</p> <p>See also Wallet for wallet usage.</p> <p>Identity in traditional blockchains is typically tied to a single wallet address. This approach limits flexibility and compromises privacy.</p> <p>On Hyli, any app can be a proof of identity. This enables you to register your preferred identity source as an app for authentication. The Hyli wallet is a tool to aggregate all these identities; we recommend using it for simplicity.</p>"},{"location":"concepts/identity/#how-hyli-processes-identity-proofs","title":"How Hyli processes identity proofs","text":"<p>A blob transaction on Hyli includes multiple blobs. One of these blobs must contain an identity claim. (If this isn't clear, read more on our transactions concept page.)</p> <ul> <li>Each blob transaction has a single identity blob.</li> <li>All provable blobs within a transaction share the same identity.</li> <li>Identity proofs include a nonce to prevent replay attacks.</li> <li>The proof verification process ensures the identity was correctly provided.</li> </ul> <p></p>"},{"location":"concepts/identity/#choosing-an-identity-source","title":"Choosing an identity source","text":"<p>When selecting an identity contract, remember:</p> <ul> <li>Identity contracts define how identity proofs are verified.</li> <li>Applications decide which identity they support. Some may enforce a specific identity type (e.g., Google accounts), while others allow multiple sources.</li> <li>Transactions can transfer Hyli tokens between different identity types, such as from a Metamask wallet to an email/password-based account.</li> <li>Users authenticate with any proof supported by their application. There are no \"Hyli wallets\".</li> </ul> <p>The identity provider should sign the entire blob transaction to ensure that all the included blobs have been approved by the user. One approach is to make the user sign the blobs they agree to execute. The identity contract then verifies that all blobs in the transaction are properly signed.</p> <p>If you don't need to create a custom identity source for your app, or don't want to do it in early development, use the Hyli wallet. It's integrated by default in our app scaffold.</p>"},{"location":"concepts/identity/#identity-verification-methods","title":"Identity verification methods","text":"<p>Hyli supports multiple identity verification methods, each with unique characteristics. Here are some of the most common.</p>"},{"location":"concepts/identity/#private-password","title":"Private password","text":"<p>A user authenticates using a private password known only to them.</p> <ul> <li>Password: private input.</li> <li>Proof: only those who know the password can generate a valid proof for these blobs.</li> <li>The proof is valid only for the blobs in this blob transaction.</li> </ul> <p></p>"},{"location":"concepts/identity/#public-signature","title":"Public signature","text":"<p>A user signs a message with their private key to prove identity.</p> <ul> <li>Signature: public input. No private input is required, since only the owner of the private key can generate a valid signature.</li> <li>Proof: anyone can generate a proof based on the public signature.</li> </ul> <p></p>"},{"location":"concepts/identity/#private-openid-verification","title":"Private OpenID verification","text":"<p>This works just like it does with a private password, except it generally can't be done client-side.</p> <p>The OpenID provider knows your secret key, so it could be able to generate transactions on  your behalf.</p> <p></p>"},{"location":"concepts/identity/#custom-identity-contracts","title":"Custom identity contracts","text":"<p>Applications on Hyli can implement custom identity verification rules through apps. A typical identity contract includes two core functions:</p> <ul> <li>Register: Users submit an initial proof of identity.</li> <li>Verify: The contract validates the proof against predefined rules.</li> </ul> <p>Applications can use this structure or define their own identity workflows as needed.</p>"},{"location":"concepts/pipelined-proving/","title":"Pipelined proving","text":""},{"location":"concepts/pipelined-proving/#pipelined-proving","title":"Pipelined proving","text":""},{"location":"concepts/pipelined-proving/#the-problem-base-state-conflicts","title":"The problem: base state conflicts","text":"<p>The Hyli Layer 1 ensures both privacy and scalability by verifying only the state transitions of apps, rather than re-executing them. This approach reduces computational overhead but introduces a critical issue for provable applications: base state conflicts.</p> <p>An app with a lot of usage will see conflicting operations, where multiple transactions reference the same base state, waiting for the previous state change to be settled.</p> <p>The time spent generating proofs delays transaction finality. Proofs require accurate timestamps, but users can't predict when their transaction will be sequenced.</p> <p>This causes parallelization limits: multiple transactions may reference the same base state, creating invalid proofs when one is settled before the other.</p> <p>We solve these issues by splitting sequencing from settlement; an operation includes two transactions.</p>"},{"location":"concepts/pipelined-proving/#blob-and-proof-transactions","title":"Blob- and proof-transactions","text":"<p>Read more on the content of blob and proof transactions on our transaction page.</p> <p>To address base state conflicts, Hyli splits operations into two transactions:</p> <ol> <li>Blob-transaction: outlines a state change for sequencing.</li> <li>Proof-transaction: provides a proof of the state change for settlement.</li> </ol> <p>From Hyli\u2019s perspective, the blob-transaction's content does not matter: it simply represents incoming information that your contract will process. For a developer, sequencing provides you with a fixed order and timestamp before proving begins. Once the transactions are sequenced, the provers can easily know upon which state they should base their proof. As a developer, you can also decide on how much information is disclosed in your blob-transaction: this is app-specific.</p> <p>Settlement happens when the corresponding proof transaction is verified and added to a block. During settlement, unproven blob transactions linked to the contract are executed in their sequencing order.</p> <p></p> <p>This separation solves all three issues shown above. The blob transaction immediately reserves a place in execution order, allowing proof generation to run without blocking other transactions. The sequencing provides an immutable timestamp, so provers know which base state to use when generating proofs and can parallelize actions.</p>"},{"location":"concepts/pipelined-proving/#unprovable-transactions","title":"Unprovable transactions","text":"<p>Even with pipelined proving, sequenced transactions that never settle can slow down the network.</p> <p>To remove this risk, Hyli enforces timeouts for blob transactions.</p> <p>Each blob transaction is assigned a specific time limit for the associated proof to be submitted and verified. Subsequent transactions can proceed without waiting indefinitely.</p>"},{"location":"concepts/pipelined-proving/#failed-transactions","title":"Failed transactions","text":"<p>If the proof isn't submitted before timeout, or if the submitted proof is invalid, the transaction is included in the block, marked as Rejected, and is ignored for state updates.</p> <p>The inclusion of the unproven transaction in the block ensures transparency, as the transaction data remains accessible.</p> <p></p>"},{"location":"concepts/proof-composition/","title":"Proof composition","text":""},{"location":"concepts/proof-composition/#proof-composition","title":"Proof composition","text":""},{"location":"concepts/proof-composition/#the-problem-clunky-interactions","title":"The problem: clunky interactions","text":"<p>In zero-knowledge systems, coordinating multiple proofs is complex. Cross-contract calls often rely on recursive verification, where Program A verifies a proof of the correct execution of Program B. This is inefficient and creates overhead at the proof generation and verification stages.</p> <p>The situation worsens when different proving schemes are involved. Most zero-knowledge systems force you to write your proofs in a unified scheme. By doing that, you lose all the advantages of specialization.</p> <p>Different proving schemes answer different needs. Some proof systems are best for client-side proving; others allow developers to use general-purpose programming languages.</p>"},{"location":"concepts/proof-composition/#the-solution-proof-composition","title":"The solution: proof composition","text":"<p>Hyli introduces native proof composition, allowing proofs to interact while remaining independent. Each proof can use the most suitable language and proving scheme, all within a single transaction.</p> <p>You benefit from composition when your transaction:</p> <ul> <li>Involves multiple applications</li> <li>Includes proofs in different languages or proving schemes</li> <li>Combines heterogeneous logic where different tools are ideal</li> </ul> <p>If everything fits cleanly within one proof, there is no composition.</p>"},{"location":"concepts/proof-composition/#cross-contract-calls-with-proof-composition","title":"Cross-contract calls with proof composition","text":"<p>Instead of recursion, Hyli lets a program declare: \"This only applies if all referenced blobs are valid.\" During settlement, all proofs are included in one transaction. Hyli verifies them together. If any proof fails, the entire transaction fails.</p> <p>This model:</p> <ul> <li>removes the need for embedded recursion;</li> <li>improves developer experience;</li> <li>reduces gas costs;</li> <li>enables parallel proving.</li> </ul>"},{"location":"concepts/proof-composition/#mixing-proof-schemes","title":"Mixing proof schemes","text":"<p>Since proofs in Hyli remain independent, each proof in a composed transaction can use its own proving scheme. Proofs are verified separately, eliminating the need to compromise for compatibility. This also enables cross-contract calls between applications using different proof systems.</p> <p>You can:</p> <ul> <li>batch heterogeneous proofs;</li> <li>call between contracts using different systems;</li> <li>choose the best proving scheme for each proof.</li> </ul>"},{"location":"concepts/proof-composition/#how-hyli-settles-multiple-proofs","title":"How Hyli settles multiple proofs","text":"<p>When a transaction includes multiple proofs, Hyli begins verifying each proof as soon as it's ready. If one fails or times out, the entire transaction is rejected.</p> <p>Proof generation is parallelized as all proofs are independent. Verification is asynchronous thanks to pipelined proving.</p>"},{"location":"concepts/proof-composition/#writing-a-cross-contract-call","title":"Writing a cross-contract call","text":"<p>Your program doesn't need to verify another program\u2019s execution directly. Instead, your contract declares claims about other apps:</p> <pre><code>MoneyApp::transfer(10, A, B) == true\nTicketApp::get(A) == ticket\n</code></pre> <p></p> <p>Each claim consists of:</p> <ul> <li>The application (MoneyApp, TicketApp)</li> <li>The function (transfer, get)</li> <li>Parameters</li> <li>A result assertion (== true, == ticket)</li> </ul> <p>See the source code from our example.</p>"},{"location":"concepts/proof-composition/#delegating-identity","title":"Delegating identity","text":"<p>Each transaction in Hyli is signed by a single identity blob. By default, this identity authorizes all blobs in the transaction.</p> <p>For cross-contract composition, Hyli supports callees, blobs that run under a different identity.</p> <p>This lets contracts trigger delegated actions without needing nested calls or recursion.</p> <p>Consider an AMM:</p> <ol> <li>Alice signs and submits a swap</li> <li>The AMM blob executes <code>swap()</code></li> <li><code>swap()</code> lists <code>transfer()</code> and <code>transferFrom()</code> as callees</li> <li>These callees run as if the AMM signed them</li> </ol> <p></p>"},{"location":"concepts/proof-composition/#caller","title":"Caller","text":"<p>The caller is the identity under which a blob executes. By default, it\u2019s the transaction signer (e.g., <code>Alice.hydentity</code>).</p> <p>If a blob is a callee, its caller becomes the blob that declared it.</p>"},{"location":"concepts/proof-composition/#callee","title":"Callee","text":"<p>A callee is a blob that runs on behalf of another blob. This lets contracts perform delegated actions without initiating their own transactions.</p> <p>For example:</p> <ul> <li>Alice signs and submits a transaction that includes a blob for an AMM swap</li> <li>The AMM swap blob declares two callees: <code>transfer</code> and <code>transferFrom</code></li> <li>These execute with the AMM as the caller</li> </ul>"},{"location":"concepts/proof-composition/#execution-and-validation","title":"Execution and validation","text":"<p>Each callee:</p> <ul> <li>Verifies that the caller blob explicitly listed it as a callee</li> <li>Checks authorization logic (e.g., <code>transferFrom</code> checks for prior <code>approve</code>)</li> </ul> <p>This approach lets users delegate logic to contracts without nested transactions, maintaining clarity and flatness in Hyli\u2019s execution model.</p>"},{"location":"concepts/proof-generation/","title":"Proof generation and submission","text":""},{"location":"concepts/proof-generation/#proof-generation-and-submission","title":"Proof generation and submission","text":"<p>Hyli allows you to build unchained applications by leveraging zero-knowledge proofs. They allow you to avoid onchain execution, guarantee privacy, and customize your application while maintaining composability with other apps.</p> <p>With Hyli, generate your proof wherever you prefer, then send it for native onchain verification and settlement. This process enables scalable, modular applications with customizable proving schemes.</p> <p>If you're a complete beginner with zero-knowledge proofs, our no-code introduction might help.</p>"},{"location":"concepts/proof-generation/#zero-knowledge-proofs-on-hyli","title":"Zero-knowledge proofs on Hyli","text":""},{"location":"concepts/proof-generation/#choose-what-you-prove","title":"Choose what you prove","text":"<p>Each application defines its proof logic. This means that each application developer can decide what information gets proven: for Hyli, proof settlement is a Success or a Failure. You define what that means for your app.</p> <p>Each app developer also defines what the public and private inputs of their app will be: what information should remain private and what should go onchain?</p>"},{"location":"concepts/proof-generation/#choose-how-you-prove","title":"Choose how you prove","text":"<p>We support as many proving schemes we can, giving you the flexibility to choose the most suitable protocol for your specific use case. Read more about our supported proving schemes.</p> <p>We also verify these natively, without the need for a ZK proof:</p> <ul> <li>sha3_256</li> <li>BLST signatures</li> <li>Secp256k1 signatures</li> </ul> <p>There are many ZK languages. Hyli aims to verify as many as possible.</p> <p>DSLs, like Circom, are specific languages that usually compile down to a specific circuit. They're good, but they're complex and may have a high learning curve.</p> <p>zkVMs prove the correct execution of arbitrary code. They allow you to build ZK applications in a certain language without having to build a circuit around it. There are two main types of zkVMs: Cairo and RISC-V. You can benchmark your Rust code and find the best zkVM for your needs with the any-zkvm template.</p> <p>We will support more types, including Cairo-based zkVMs and DSLs, in the future, and plan to support all major proving schemes eventually.</p>"},{"location":"concepts/proof-generation/#how-to-generate-proofs","title":"How to generate proofs","text":""},{"location":"concepts/proof-generation/#choose-where-you-prove","title":"Choose where you prove","text":"<p>Each application can generate its proof in whichever place fits best.</p> Pros Cons When to use Client-side (browser, mobile app) Maximum privacyData ownership Requires robust client-side hardware Personal data that should remain private External prover or proving market No client-side costs or constraintsOffload proof generation to the experts Requires trusting the external prover with your inputs Resource-intensive and not privacy-sensitive proofs By the application itself Simple UXNo dependenciesCode can be private Higher infrastructure needsPotential liveness issue Confidential or centralized applications"},{"location":"concepts/proof-generation/#autoproving-through-our-scaffold","title":"Autoproving through our scaffold","text":"<p>Hyli\u2019s scaffold includes a built-in AutoProver service that automatically detects transactions related to your contract. It generates the corresponding proof and submits the associated proof transaction to Hyli.</p> <p>With autoproving in place, you don\u2019t need to manage custom proving flows. Just write your contract and connect a frontend\u2014the scaffold handles everything else. This setup is ideal for projects where you want minimal backend setup and an easier onboarding experience.</p> <p>Visit the scaffold repository or follow the quickstart instructions.</p>"},{"location":"concepts/proof-generation/#our-proof-generation-partners","title":"Our proof generation partners","text":"<p>If you choose to work with an external prover or proving market, you can choose from one of our partners in that area and benefit from a better Hyli integration.</p>"},{"location":"concepts/proof-generation/#submitting-a-proof-to-hyli","title":"Submitting a proof to Hyli","text":"<p>Read more about the transaction lifecycle on our transactions overview.</p> <p>First, your application sends a blob transaction to Hyli.</p> <p>Thanks to pipelined proving, once a transaction is submitted, it is sequenced.</p> <p>You can then start generating your proof using the sequenced virtual base state as the base state for your operation.</p> <p>Once sent, the proof goes through Hyli\u2019s native verification, removing the need for verifier contracts.</p> <p>Once verified, the proof is settled onchain. Use this settled state to update your app accordingly outside of Hyli.</p>"},{"location":"concepts/proof-generation/#external-resources","title":"External resources","text":"<ul> <li>Zero-knowledge proofs explained at 5 levels of difficulty (22')</li> <li>awesome-zk link repository on GitHub</li> <li>Hyli's very simple introduction to zero-knowledge proofs</li> <li>Lauri Peltonen's blog series on ZK</li> </ul>"},{"location":"concepts/transaction/","title":"Transactions on Hyli","text":""},{"location":"concepts/transaction/#transactions-on-hyli","title":"Transactions on Hyli","text":"<p>Hyli introduces a novel transaction model that separates intent from proof, optimizing for scalability and privacy.</p> <p>Unlike traditional blockchains, where transactions are executed and proven in a single step, Hyli employs a two-step process called pipelined proving:</p> <ol> <li>Blob-transaction: outlines a state change for sequencing.</li> <li>Proof-transaction: provides a proof of the state change for settlement.</li> </ol> <p>Each proof transaction verifies a single blob, unless you use recursion. If a blob transaction contains multiple blobs, each requires a separate proof.</p> <p>Once all blobs are proven, the blob transaction is settled, and the referenced contract states are updated.</p>"},{"location":"concepts/transaction/#blob-transaction-structure","title":"Blob transaction structure","text":"<p>Blobs are not your proof: they're your proof's public wrapper. Their job is to describe what should happen (e.g. a token transfer, a vote cast) and provide enough information for the blockchain to verify the proof.</p> <p>A blob transaction consists of:</p> <ul> <li>An identity string. See identity.</li> <li>A list of blobs, each containing:<ul> <li>A contract name (string).</li> <li>A data field (binary), which the contract parses.</li> </ul> </li> </ul> <p>A blob should clearly encode the expected onchain effects (e.g. the token amount and destination, in the case of a token transfer). It should not duplicate all proof inputs just to \"explain\" what the proof does.</p> <p>Blobs should never include private inputs. If there is secret data, include hashes or commitments to secret data but do not include it raw.</p> <p>Example</p> <p>In a proof that checks whether a password is correct:</p> <ul> <li>\u2705 Blob: {\"username\": \"bob\", \"password_hash\": \"0xabc123\"}</li> <li>\u274c Blob: {\"username\": \"bob\", \"password\": \"hunter2\"}</li> </ul>"},{"location":"concepts/transaction/#proof-transaction-structure","title":"Proof transaction structure","text":"<p>A proof transaction includes:</p> <ul> <li>A contract name (string).</li> <li>Proof data (binary), containing:<ul> <li>A zero-knowledge proof.</li> <li>The app output.</li> </ul> </li> </ul> <p>For Risc0 and SP1, the proof data's app output follows <code>HyleOutput</code> as defined in the smart contract ABI.</p>"},{"location":"concepts/transaction/#example-token-transfer","title":"Example: token transfer","text":"<p>A token transfer involves two blobs in a blob transaction:</p> <ul> <li>Identity blob: Verifies the sender\u2019s identity and authorizes the transfer.</li> <li>Transfer blob: Executes the token transfer.</li> </ul> <p>Each blob requires a corresponding proof transaction.</p>"},{"location":"concepts/transaction/#blob-transaction","title":"Blob transaction","text":"<pre><code>{\n    \"identity\": \"bob@MyIdentityContract\",\n    \"blobs\": [\n        {\n            \"contract_name\": \"MyIdentityContract\",\n             // Binary data for the operation of MyIdentityContract\n             // VerifyIdentity { account: \"bob@MyIdentityContract\", nonce: \"2\" }\n            \"data\": \"[...]\" \n        },\n        {\n            \"contract_name\": \"MyToken\",\n             // Binary data for the operation of MyToken contract\n             // Transfer { recipient: \"alice@MyIdentityContract\", ammount: \"20\" }\n            \"data\": \"[...]\"\n        }\n    ]\n}\n</code></pre>"},{"location":"concepts/transaction/#proof-transactions","title":"Proof transactions","text":""},{"location":"concepts/transaction/#identity-proof","title":"Identity proof","text":"<pre><code>{\n    \"contract_name\": \"MyIdentityContract\",\n    \"proof\": \"[...]\"\n}\n</code></pre> <p>The binary proof's output includes:</p> <ul> <li>Initial state: <code>bob@MyIdentityContract</code> nonce = 1.</li> <li>Next state: <code>bob@MyIdentityContract</code> nonce = 2.</li> <li>Index: 0 (first blob in the transaction).</li> </ul> <p>and</p> <pre><code>{\n    \"contract_name\": \"MyToken\",\n    \"proof\": \"[...]\"\n}\n</code></pre> <p>The binary proof's output includes:</p> <ul> <li>Initial state: <code>bob@MyIdentityContract</code> balance = 100, <code>alice@MyIdentityContract</code> balance = 0.</li> <li>Next state: <code>bob@MyIdentityContract</code> balance = 80, <code>alice@MyIdentityContract</code> balance = 20.</li> <li>Index: 1 (second blob in the transaction).</li> </ul>"},{"location":"guide/","title":"\ud83c\udf0d Primer","text":""},{"location":"guide/#primer","title":"\ud83c\udf0d Primer","text":"<p>Welcome to the Hyli primer.</p> <p>It is your entry point into understanding Hyli. The book is divided into four sections and uses minimal code to serve a bigger audience.</p> <p>If you want to build on Hyli, you may want to check out the quickstart or concept pages.</p> <p>The beginnings</p> <p>How Hyli started and its early story.</p> <p>Why Hyli?</p> <p>Why Hyli matters.</p> <p>Core components of Hyli</p> <p>How Hyli built the proof-powered blockchain and what makes it special.</p> <p>The future</p> <p>The future of Hyli and of proof-powered blockchains.</p>"},{"location":"guide/components/","title":"Core components of Hyli","text":""},{"location":"guide/components/#core-components-of-hyli","title":"Core components of Hyli","text":"<p>This section introduces various primitives and components that Hyli has developed to implement a novel Layer 1 that can meet the world\u2019s demand for computation.</p>"},{"location":"guide/components/#offchain-execution","title":"Offchain execution","text":"<p>Hyli's design is opinionated, focusing only on sequencing, data availability, and verifying zk proofs. This focus enables it to delegate computation to apps. Since execution is verifiable thanks to cryptographic techniques, the system remains decentralized and trustless.</p> <p>Traditional Layer 1s suffer from a lack of horizontal scalability as they pursue a single layer with all components integrated: sequencing, validation, execution, and state. They become bottlenecked as the demand for execution and state increases.</p> <p>An increase in demand for these L1s means managing more application state and more computation on a single layer. To meet the demand, they increase resource requirements for validators: larger and faster disks, higher network bandwidth, more RAM, and more computer cores.</p> <p>This is where Hyli shines.</p> <p>Hyli only sequences the transactions for applications. The applications are responsible for validating these transactions, executing them, and managing the application state. This allows Hyli to scale horizontally because all applications handle their validation, execution, and state management.</p> <p></p> <p>Hyli scales decentralized applications the way the internet has scaled, which is through horizontal scaling, and hence is pursuing the endgame architecture of building a universal proof layer.</p>"},{"location":"guide/components/#transactions-on-hyli","title":"Transactions on Hyli","text":"<p>Hyli provides two transaction types, which are:</p> <ul> <li>Blob transactions  </li> <li>Proof transactions</li> </ul> <p>Let\u2019s take a look at both individually.</p>"},{"location":"guide/components/#blob-transactions","title":"Blob transactions","text":"<p>Hyli is the source of truth for the order of transactions for applications.</p> <p>Blob transactions provide an application transaction to be sequenced (ordered) and finalized on Hyli. This transaction contains a payload, which includes data that an application can use to verify and execute it.</p> <p></p> <p>This way, multiple application transactions are sequenced and finalized on Hyli, and their verification and execution are handled directly by the applications.</p>"},{"location":"guide/components/#proof-transactions","title":"Proof transactions","text":"<p>After your transaction has been sequenced and finalized on Hyli, the application executes it and needs to settle the application state post-execution. </p> <p>This is where Proof transactions come into play.  </p> <p></p> <p>Once a transaction has been sequenced on Hyli, a Proof transaction follows, accompanied by a proof and the new application state. Once a proof transaction has been provided and successfully verified for a previous blob transaction, that blob transaction and its corresponding application state can be considered settled.</p> <p>Read more about transactions on Hyli.</p>"},{"location":"guide/components/#why-separate-sequencing-from-proving","title":"Why separate sequencing from proving?","text":"<p>Having separate transactions for sequencing and proving an application enables a Web2-like user experience while maintaining decentralization and security. Proving will never be fully instantaneous, and pipelined proving easily removes this overhead time.</p> <p>For example, imagine doing a swap on Hyli, rather than waiting for a proof to be generated:</p> <ol> <li>The user transaction is immediately sequenced.  </li> <li>The application immediately executes it and provides the latest application state to the user (which would be confirmation that their swap is done).  </li> <li>The user can keep using the app. Meanwhile, the new state proving happens asynchronously in the background. The app will roll back if proving fails.</li> </ol> <p>This has the added benefit of avoiding initial state conflicts.</p> <p>Read more about pipelined proving on Hyli.</p>"},{"location":"guide/components/#consensus-autobahn","title":"Consensus: Autobahn","text":"<p>Hyli is pursuing a new design by only focusing on sequencing and verifying proofs. This means that it doesn\u2019t get bottlenecked by onchain computation and the corresponding state growth.</p> <p>This also means that the faster Hyli can propagate data and finalize transactions, the faster the apps built on top of Hyli will be.</p> <p>This is why Hyli uses Autobahn as its consensus mechanism. It allows multiple concurrent proposers and uses data availability certificates for fast finality.</p> <p>Autobahn enables Hyli to process more data and finalize transactions faster than traditional BFT consensus algorithms, such as Tendermint. It makes Hyli the best choice for building low-latency, high-throughput applications.</p> <p>Multiple concurrent proposers also provide censorship resistance: transactions are sent to multiple validators to ensure inclusion, even if one of them is censoring the user.</p> <p> </p> <p>In Autobahn, every proposer maintains its unique lane, where it proposes new batches and disseminates them to other validators. In parallel, validators finalize various batches into a single block. A block is finalized once it has received a threshold number of signatures.</p> <p>The approach helps decouple data dissemination from the consensus over this data, unlocking higher throughput and faster finality.</p> <p></p> <p>Autobahn makes Hyli the destination for building high-throughput, low-latency applications, from onchain games to onchain order books.</p> <p>Read more about consensus on Hyli.</p>"},{"location":"guide/components/#application-architecture-on-hyli","title":"Application architecture on Hyli","text":"<p>Hyli provides a new infrastructure for building the next generation of scalable, secure, cryptographically protected applications. This also means building an application differs from the traditional developer experience of using smart contracts.</p> <p>Let\u2019s dive deep into the various components of building an app on Hyli.</p> <p>There are a few important things an application needs:</p> <ol> <li>Ordering of transactions  </li> <li>Execution of the app logic for the finalized transactions  </li> <li>State updates after successful execution</li> </ol>"},{"location":"guide/components/#ordering-of-transactions","title":"Ordering of transactions","text":"<p>Hyli takes care of this part. With its Autobahn consensus under the hood, it provides very fast sequencing so builders know what base state they need to use for their proof.</p>"},{"location":"guide/components/#execution-of-finalized-transactions","title":"Execution of finalized transactions","text":"<p>Users send the actions they intend to take (such as making a swap or buying a game asset) via blob transactions, which Hyli sequences and finalizes.</p> <p>Once transactions have been finalized on Hyli, applications can start consuming their respective transactions and verifying and executing the app logic. For this, applications host their apps off-chain. Unlike smart-contract-based execution, this approach enables Hyli to break free from the burden of onchain computation and state, which is a significant bottleneck for other L1s.</p> <p>The application executes its transactions and creates a proof of successful execution using whatever stack works best for the developer. Users interact directly with the application to get the status of their transaction's execution.</p> <p>As more applications come, the system scales horizontally and doesn\u2019t burden or hamper Hyli.</p>"},{"location":"guide/components/#state-updates","title":"State updates","text":"<p>This is the final stage of executing an application transaction: committing the latest state of the application after a transaction has been executed. This ensures the application's verifiability and also protects users in various scenarios, such as withdrawing funds from the application.</p> <p>Applications on Hyli maintain their state off-chain and can leverage various storage options, including decentralized storage providers such as Arweave, Filecoin, and Walrus, or centralized ones like Amazon S3 and Cloud Storage.</p> <p>Applications only commit a small, fixed-sized commitment to their application state and periodically publish new state roots after applying a transaction, along with a validity proof.</p> <p>This allows Hyli to escape the state growth problem, which has plagued blockchains since their dawn. On legacy blockchains, as more applications emerge and grow, so does their storage, which every validator in the network must bear. Hyli enables provable applications with validity proofs. Applications only submit their latest state commitment; the state remains off-chain, but all updates to the application are verifiable via validity proofs, allowing the state to be easily reconstructed.</p> <p>This enables the creation of bulletproof, secure, and scalable apps that are sustainable over time as they grow.</p>"},{"location":"guide/components/#practical-example-a-dex-on-hyli","title":"Practical example: a Dex on Hyli","text":"<p>Let\u2019s take the example of a transaction of a Dex product on Hyli and examine the lifecycle of a user transaction.</p>"},{"location":"guide/components/#step-1-user-sends-a-transaction","title":"Step 1: User sends a transaction","text":"<p>The user sends transactions describing their intended actions, such as deploying liquidity, withdrawing liquidity, or swapping.</p> <p>At this point, nothing has been proved.</p>"},{"location":"guide/components/#step-2-dex-application-consumes-the-transaction","title":"Step 2: Dex application consumes the transaction","text":"<p>The Dex application follows the Hyli L1 with the help of an indexer. It consumes every new block, filters out the transactions intended for itself, applies the application logic, and updates the respective state.</p> <p>The developer is free to write their application in any language of their choice as long as they can generate a validity proof for it! This could be Rust, C++, or domain-specific languages like Cairo, Noir, Circom, etc.</p> <p>The application state typically resides in a decentralized storage layer.</p>"},{"location":"guide/components/#step-3-user-gets-confirmation-on-their-transaction","title":"Step 3: User gets confirmation on their transaction","text":"<p>Users don\u2019t need to wait for their transaction to be proven to get a confirmation. The application provides immediate confirmation post-execution and updates its state temporarily. This is a softer confirmation than the proof being settled, but since the application generates validity proofs, it cannot lie to the user.</p> <p>This enables the creation of a real-time user experience for our Dex. The user sends the transactions, which are immediately finalized and executed, and then the user is free to take any business action on top of it.</p>"},{"location":"guide/components/#step-4-transaction-is-proven-and-settled","title":"Step 4: Transaction is proven and settled","text":"<p>The application asynchronously proves all transactions. This proof can be generated by a prover network like Boundless or Succinct, by the application itself, or event client-side: in the context of our Dex, the app generates the proofs.</p> <p>Once the proof has been generated, the application finalizes the transaction with a proof transaction, which also includes the app's new state commitment.</p> <p>Since applications built on Hyli provide validity proofs, everything the indexer follows and operates on top is proved and verified on Hyli for integrity. Hyli verifies the proof and settles the transaction, updating the application's new state onchain. What was \"sequenced\" is now \"confirmed\": the app can update its state for good and the user gets a final confirmation.</p> <p>Hyli's approach to building applications enables the creation of scalable, secure, verifiable, and censorship-free apps that deliver real-time, Web2-like latencies and user experiences.</p> <p>Hyli is the endgame for building verifiable apps!</p>"},{"location":"guide/future/","title":"A vision of the future with Hyli","text":""},{"location":"guide/future/#a-vision-of-the-future-with-hyli","title":"A vision of the future with Hyli","text":"<p>This final section of the guide discusses the future that Hyli aims to bring forward. Discussions span from the end-user experiences that Hyli will make possible to the evolution of infrastructure and new market opportunities the stack can create.</p>"},{"location":"guide/future/#a-world-full-of-verifiable-apps-on-hyli","title":"A world full of verifiable apps on Hyli","text":"<p>Hyli is the next evolution of user applications: sovereign, verifiable, and censorship-resistant. Applications built on Hyli offer these properties without compromising on user experience and speed.</p> <p>One of the key features of applications built on top of Hyli is their ability to interoperate with each other easily. Multiple instructions can be sent via a single blob transaction, and through sync and async protocols, a single transaction can span across multiple applications.</p>"},{"location":"guide/future/#interoperable-applications","title":"Interoperable Applications","text":"<p>You could withdraw liquidity from a money market, swap with the asset on a different application, and deposit liquidity for the swapped asset back to the money market, all in a single transaction. And each of these apps is a different rollup: no need for bridges, everything is natively composable.</p> <p></p> <p>Hyli is building the settlement layer of the next wave of internet applications, enabling anyone to perform multiple interactions with these applications in a single transaction. It\u2019s a better way to build applications.</p>"},{"location":"guide/future/#private-apps","title":"Private Apps","text":"<p>One of the key components in the Hyli architecture is that applications only post state commitment to Hyli, so the application state itself is off-chain: the proof is what guarantees the integrity of any action, even if the details of the action are not made public. This enables the development of private applications on Hyli.</p> <p>Take, for example, a private payments app. In such a system, each user's balance is encrypted and private by default. Users generate zero-knowledge proofs that their transactions are valid (e.g., that they own sufficient funds and are transferring them correctly) without ever revealing their balance or transaction history.</p> <p>Because of Hyli\u2019s design, we can achieve both privacy and high TPS, which is not imaginable on the vast majority of privacy-first chains.</p> <p>These proofs are submitted onchain, and the protocol verifies them without decrypting the underlying data. This enables full privacy while maintaining the system's integrity.</p> <p>Hyli, due to its high data throughput, serves as the backbone for the construction of a new wave of privacy-focused applications, where Hyli handles ordering and censorship resistance. At the same time, apps focus on fast, privacy-protecting execution.</p>"},{"location":"guide/future/#uncensorable-applications","title":"Uncensorable Applications","text":"<p>Hyli is building the common source of truth for the new wave of internet applications. Hyli verifies proofs of what has happened (user transactions) and in what order.</p> <p>Applications on Hyli must respect transactions sent to Hyli and their order, as this is a core part of their application logic that needs to be verified on Hyli to advance the application state.</p> <p>Hyli\u2019s innovation lies in its fast data dissemination and finality via Autobahn. Users directly submit their transactions to Hyli, where they are finalized very quickly. Once finalized, transactions are guaranteed for execution by the corresponding applications.  </p> <p></p> <p>Hyli has multiple concurrent proposers, which means users can send their transactions to multiple proposers in parallel, protecting them from being censored by a single proposer. This ensures that both Hyli and its applications are censorship-resistant for their users.</p>"},{"location":"guide/future/#proving-networks","title":"Proving Networks","text":"<p>Hyli enables verifiable, censorship-resistant applications and leverages proofs as a core part of building these applications: Hyli applications rely on proving their application logic.</p> <p>Rather than execute code directly on a blockchain, the provers and proving networks become the execution engine: the code is executed there, proven, and verified on Hyli.</p> <p></p> <p>Teams like Boundless, Succinct, Fermah, and zkCloud have been working on decentralized proving networks.</p> <p>A proving network as a piece of infrastructure ensures that applications on Hyli:</p> <ul> <li>Don\u2019t have a central point of failure  </li> <li>Get the most cost-efficient and fastest proving services  </li> <li>Benefit from highly efficient proving infrastructure</li> </ul> <p>In a decentralized proving network, operators compete to be the fastest, the cheapest, and the most reliable. At the same time, multiple providers eliminate any central point of failure.</p> <p>The Hyli stack, along with its wave of new internet applications, will create sustained demand for these proving networks, thereby also accelerating cheaper and faster proving. This will have a net positive impact on the ecosystem.</p>"},{"location":"guide/future/#the-fastest-most-abundant-da-layer","title":"The fastest, most abundant DA layer","text":"<p>Hyli, with its Autobahn consensus, is all set to break the limits of how fast data can be disseminated and finalized by a decentralized set of validators.</p> <p>Since Hyli focuses only on data availability and proof verification, it is laser-focused on scaling these two properties:</p> <ul> <li>The amount of data that can be propagated, finalized, and made available;  </li> <li>The number of integrity proofs that the chain can verify per second.</li> </ul> <p>The above focus makes Hyli the default choice for applications looking for a data availability solution.</p> <p>Applications such as chat applications, AI agents, decentralized courts, and governance platforms can all utilize Hyli to store their data and make it available for a meaningful period.</p> <p>Hyli will continue to push the metrics on data availability, speed of finalization, and the number of proofs it can verify, leveraging ever-improving technology and the continuous decentralization of its validator set. Hyli is well-positioned to be the world\u2019s fastest, most abundant DA layer.</p> <p>Follow Hyli on X to stay updated with the latest developments in the Hyli ecosystem and explore our roadmap.</p>"},{"location":"guide/why-hyli/","title":"Why Hyli?","text":""},{"location":"guide/why-hyli/#why-hyli","title":"Why Hyli?","text":"<p>Blockchains today have issues.</p> <p>When the Hyli co-founders first thought of the blockchain they wanted to create, zero-knowledge proofs had become very practical to scale execution. This made them wonder: Why does the L1 even handle execution? Why not just sequence the transaction and verify the proofs? And if something other than zero-knowledge proofs appeared, how would that L1 support it?</p> <p>So the question was how to create a new Layer 1 with a future-proof architecture that can scale and solve these limitations. The answer: a Layer 1 that can horizontally scale thanks to validity proofs, handle millions of TPS, and never get burdened with the ever-growing onchain state.</p> <p>This section explores why we work on Hyli. As you read, you\u2019ll understand why the Hyli architecture is the endgame of blockchain infrastructure.</p>"},{"location":"guide/why-hyli/#a-history-of-blockchain-architecture","title":"A history of blockchain architecture","text":"<p>Let\u2019s start by recapping the evolution of blockchain architectures. That way, we can understand how we arrived at this point and the next set of challenges that the Hyli architecture addresses.</p>"},{"location":"guide/why-hyli/#bitcoin-the-first-app-chain","title":"Bitcoin: The first app chain","text":"<p>It all starts with Bitcoin, an app-specific chain built after the 2008 financial crisis to solve the problems of sound money.</p> <p>Bitcoin tackled the hard problems of that time: creating a sound digital asset that is permissionless to use, offers self-custody, and is secured by mathematical and economic security.</p> <p>Bitcoin solved critical problems, but it had issues:</p> <ul> <li>Not scalable, \\ ~7 TPS  </li> <li>Not highly programmable. You cannot build complex applications with it.</li> </ul> <p></p> <p>Following the creation of Bitcoin, people started building app-specific chains.</p> <p>The issue with the model is that economic security cannot be shared between these app chains, and every app needs to bootstrap its economic security from scratch.</p>"},{"location":"guide/why-hyli/#ethereum-the-first-general-purpose-chain","title":"Ethereum: The first general-purpose chain","text":"<p>Ethereum was launched to solve the lack of general-purpose programmability.</p> <p>It ships with the EVM (Ethereum Virtual Machine), which allows for launching a suite of applications on the same base chain. This has led to the boom of DeFi and primitives such as AMMs, Money Markets, and NFTs.</p> <p>All these apps could launch directly on top of Ethereum, inheriting its economic security.</p> <p>However, Ethereum operates at \\~15-20 TPS and thus becomes very expensive to use during periods of high usage and congestion.</p> <p>Ethereum did not solve the scalability problem.</p> <p></p>"},{"location":"guide/why-hyli/#solana-the-first-high-throughput-general-purpose-chain","title":"Solana: The first high-throughput general-purpose chain","text":"<p>Solana was launched with a new execution model, incorporating parallelization to provide high throughput on a general-purpose chain.</p> <p>Now, you can build onchain apps and distribute them with low fees.</p> <p>Solana currently achieves \\~1,000 true TPS and plans to grow that number.  </p> <p></p> <p>Solana has inspired multiple other chains that also aim to increase throughput, such as Sui, Aptos, Sei, Monad, etc.</p>"},{"location":"guide/why-hyli/#problems-with-existing-layer-1-architecture","title":"Problems with existing Layer 1 architecture","text":"<p>General-purpose high-throughput chains are emerging. However, we haven\u2019t yet solved the scaling problem.</p> <p>No single chain can be the world computer.</p> <p>To scale and meet the demand for decentralized, permissionless, and trustless computing, Layer 1s have focused on scaling a single chain vertically.</p> <p>This quest is misguided. The truth is that the internet itself has scaled horizontally. There is no single server that meets the world's demand for Web2 applications, and the same holds true for blockchains.</p> <p>You can build a 100k+ TPS chain, but eventually, the world\u2019s demand will grow enough that scaling onchain compute will be a problem again. You cannot solve blockspace congestion, slowness, and high fees by scaling a single chain.</p> <p>The ultimate goal is a horizontally scalable, decentralized infrastructure for building applications.</p> <p>Proofs open up a new design space.</p> <p>The current innovation in cryptography, particularly zero-knowledge proofs, has enabled a new approach to building verifiable applications.</p> <p>Rather than relying on multiple machines replicating the same app logic, a single validity proof can be generated. The proof makes the app's state instantly verifiable for millions of devices, even those that would not be powerful enough to execute the app\u2019s logic.</p> <p>This paves the way for a new blockchain architecture where applications run computations off-chain and periodically settle proof of their state transition to a common settlement layer.</p> <p>The Layer 1 of tomorrow must do sequencing, DA, and verification of validity proofs. Nothing else.</p> <p>With zero-knowledge proofs, now the Layer 1 can just focus on:</p> <ul> <li>Sequencing: ordering transactions for applications  </li> <li>Data availability: making sure that the data is available for verification  </li> <li>Verification: verifying that applications are working correctly and settling onchain accordingly</li> </ul> <p>This way, all the computation can be left to the choice of app builders. An app can use a Layer 1 to order transactions and resist censorship while providing periodic proofs of its correct behavior.</p>"},{"location":"guide/why-hyli/#hyli-speedrunning-the-layer-1-endgame","title":"Hyli: speedrunning the Layer 1 endgame","text":"<p>We introduce Hyli, a Layer 1 that fixes the issues outlined above.</p> <p>Hyli is a new Layer 1 blockchain that focuses only on sequencing, data availability, and proof verification. The computation is handled directly via the apps. This lays the foundation for a horizontally scalable, decentralized network of applications that are performant, secure, and interoperable.</p> <p>This novel architecture allows us to focus only on increasing speed and scalability, allowing us to design and innovate in ways that traditional general-purpose Layer 1s cannot.</p> <p>Hyli uses various new primitives to ship the fastest and most cost-effective L1 of its type. It uses AutoBahn, a new consensus with Multiple Concurrent Proposers, for faster data propagation and finalization.</p> <p>It enshrines various proof system verifications, allowing for the building of verifiable apps with superior DX. zkVMs, such as SP1 and RISC-0, and zkDSLs, like Noir, are already live on Hyli, with more in the pipeline.</p> <p></p> <p>Hyli allows you to just build your app.</p> <p>Bring your zkVM and use whatever language you want. You get censorship-resistant ordering and verifiability out of the box, allowing you to focus on building and distributing your app.</p> <p>The use of a common sequencing and verification layer also enables interoperability between all Hyli-based apps without bridges.</p> <p>Most importantly, this architecture scales horizontally. As more clients join the network, verifications are horizontally distributed among them and do not reach the bottleneck that the current L1s have been suffering from, thanks to our state-of-the-art consensus protocol based on Autobahn.</p>"},{"location":"quickstart/","title":"\ud83c\udfc1 Quickstart","text":""},{"location":"quickstart/#quickstart","title":"Quickstart","text":"<p>Welcome to the Quickstart guide for Hyli.</p> <p>It uses several examples to help you start building as soon as possible.</p> <p>Run the scaffold locally</p> <p>Where it all begins.</p> <p>Build your app</p> <p>Using our scaffold repository, set up your application.</p>"},{"location":"quickstart/edit/","title":"Build your app","text":""},{"location":"quickstart/edit/#build-your-app","title":"Build your app","text":""},{"location":"quickstart/edit/#important-editing-a-contract","title":"IMPORTANT: Editing a contract","text":"<p>If you make changes to the contracts, you need to execute this command in the node, the wallet, and the scaffold to restart them:</p> <pre><code>rm -rf data_node &amp;&amp; RISC0_DEV_MODE=true SP1_PROVER=mock cargo run -- --pg\n</code></pre> <p>If you do not do this, you will see an error about a program id mismatch in the server.</p>"},{"location":"quickstart/edit/#how-the-scaffold-is-built","title":"How the scaffold is built","text":"<p>The scaffold comes with a built-in autoprover and server implementation, so you can focus on your contracts and frontend.</p> <p>The scaffold includes the following folders:</p> <ul> <li><code>front/</code>, a basic frontend with a wallet integration;</li> <li><code>contracts/</code>, two Risc0 contracts for a default app;</li> <li><code>server/</code>, the autoprover logic.</li> </ul> <p>The application follows a client-server model:</p> <ul> <li>The frontend sends operation requests to the server.</li> <li>The server handles transaction creation, proving, and submission. </li> <li>All interactions go through the Hyli network.</li> </ul>"},{"location":"quickstart/edit/#add-your-contracts","title":"Add your contracts","text":"<p>Place your <code>.rs</code> app files in the <code>contracts/</code> directory.</p> <p>For examples of contracts, you can look at examples from our supported proving schemes.</p>"},{"location":"quickstart/edit/#add-your-frontend","title":"Add your frontend","text":"<p>Put your frontend code in the <code>front/</code> directory. By default, we've implemented the Hyli wallet.</p> <p>Make sure the frontend connects to the backend at the expected route (<code>/prove</code>, <code>/submit</code>, etc.), or adapt accordingly.</p>"},{"location":"quickstart/edit/#start-the-server","title":"Start the server","text":"<p>In the root of the scaffold, start the backend server:</p> <pre><code>RISC0_DEV_MODE=1 cargo run -p server\n</code></pre> <p>This starts the backend service, which handles contract interactions and proofs.</p>"},{"location":"quickstart/edit/#open-the-frontend-interface","title":"Open the frontend interface","text":"<p>From the <code>front/</code> directory, install dependencies and run the dev server:</p> <pre><code>cd front\nbun install\nbun run dev\n</code></pre> <p>This starts the local frontend interface to interact with the Hyli network.</p>"},{"location":"quickstart/run/","title":"Run the scaffold locally","text":""},{"location":"quickstart/run/#run-the-scaffold-locally","title":"Run the scaffold locally","text":""},{"location":"quickstart/run/#prerequisites","title":"Prerequisites","text":"<ul> <li>Install Rust (you'll need <code>rustup</code> and Cargo).</li> <li>Install openssl-dev (e.g. <code>apt install openssl-dev</code> or <code>cargo add openssl</code>).</li> <li> <p>Bun (or npm/yarn)</p> </li> <li> <p>For the scaffold example, install RISC Zero and Noir. You can also use SP1.</p> </li> </ul>"},{"location":"quickstart/run/#run-a-node-locally","title":"Run a node locally","text":"<p>Clone the Hyli node.</p> <p>Run:</p> <pre><code>git checkout v0.13.1\nrm -rf data_node &amp;&amp; RISC0_DEV_MODE=true SP1_PROVER=mock cargo run -- --pg\n</code></pre> <p>You can now use the Hyli explorer. Select <code>localhost</code> in the upper-right corner.</p> <p>For alternative setups, optional features, and advanced configurations, check out the local node reference page.</p>"},{"location":"quickstart/run/#run-the-wallet","title":"Run the wallet","text":"<p>Clone the Wallet repository.</p> <p>Wait until the node has successfully launched.</p> <p>Run:</p> <pre><code>git checkout v0.1.2\nrm -rf data 2&gt;/dev/null || true &amp;&amp; clear &amp;&amp; RISC0_DEV_MODE=true SP1_PROVER=mock cargo run --bin server --release -- -m -a -w\n</code></pre>"},{"location":"quickstart/run/#run-the-app-scaffold","title":"Run the app scaffold","text":"<p>Clone the Hyli app scaffold.</p> <p>Launch the server:</p> <pre><code>rm -rf data 2&gt;/dev/null || true &amp;&amp; clear &amp;&amp; RISC0_DEV_MODE=true SP1_PROVER=mock cargo run --bin server --release\n</code></pre> <p>Start the scaffold's UI:</p> <pre><code>cd front\nbun install &amp;&amp; bun run dev\n</code></pre> <p>Everything is now functional. We can now explore the scaffold!</p>"},{"location":"reference/","title":"Reference","text":""},{"location":"reference/#reference","title":"Reference","text":"<p>This section provides key reference materials related to Hyli.</p>"},{"location":"reference/local-node/","title":"Local node configuration","text":""},{"location":"reference/local-node/#local-node-configuration","title":"Local node configuration","text":""},{"location":"reference/local-node/#recommended-run-from-source","title":"Recommended: Run from source","text":"<p>For a single local node (consensus disabled) with an indexer, clone the hyli repository and run:</p> <pre><code>cargo run -- --pg\n</code></pre> <p>This command starts a temporary PostgreSQL server and erases its data when you stop the node.</p>"},{"location":"reference/local-node/#optional-persistent-storage","title":"Optional: Persistent storage","text":"<p>For persistent storage, start a standalone PostgreSQL instance:</p> <pre><code># Start PostgreSQL with default configuration:\ndocker run -d --rm --name pg_hyle -p 5432:5432 -e POSTGRES_PASSWORD=postgres postgres\n</code></pre> <p>Then, navigate to the Hyli root and run:</p> <pre><code>cargo run\n</code></pre>"},{"location":"reference/local-node/#alternative-start-with-docker","title":"Alternative: Start with Docker","text":"<p>Use Docker to run a local node.</p>"},{"location":"reference/local-node/#pull-the-docker-image","title":"Pull the Docker image","text":"<pre><code>docker pull ghcr.io/hyli-org/hyli:v0.12.1\n</code></pre>"},{"location":"reference/local-node/#run-the-docker-container","title":"Run the Docker container","text":"<pre><code>docker run -v ./data:/hyle/data -p 4321:4321 ghcr.io/hyli-org/hyli:v0.12.1\n</code></pre> <p>If you run into an error, try adding the <code>--privileged</code> flag:</p> <pre><code>docker run --privileged -v ./data:/hyle/data -p 4321:4321 ghcr.io/hyli-org/hyli:v0.12.1\n</code></pre> <p>To run with an indexer, add the parameter <code>-e HYLE_RUN_INDEXER=true</code> and set up a running PostgreSQL server with Docker:</p> <pre><code>docker run -d --rm --name pg_hyle -p 5432:5432 -e POSTGRES_PASSWORD=postgres postgres\n</code></pre> <p>And the node linked to it:</p> <pre><code>docker run -v ./data:/hyle/data \\\n    -e HYLE_RUN_INDEXER=true \\\n    -e HYLE_DATABASE_URL=postgres://postgres:postgres@pg_hyle:5432/postgres \\\n    --link pg_hyle \\\n    -p 4321:4321 \\\n    ghcr.io/hyli-org/hyli:v0.7.2\n</code></pre> <p>You can now create your first app.</p> <p>Tip</p> <p>To reset your local node, delete the ./data folder and restart from Step 1. Otherwise, you risk re-registering a contract that still exists.</p>"},{"location":"reference/local-node/#alternative-build-the-docker-image-locally","title":"Alternative: Build the Docker image locally","text":"<p>If you prefer to build the image from source, run:</p> <pre><code>docker build -t hyli-org/hyli . &amp;&amp; docker run -dit hyli-org/hyli\n</code></pre>"},{"location":"reference/local-node/#configuration","title":"Configuration","text":"<p>You can configure your setup using environment variables or by editing a configuration file.</p>"},{"location":"reference/local-node/#using-a-configuration-file","title":"Using a configuration file","text":"<p>To load settings from a file, place <code>config.toml</code> in your node's working directory. It will be detected automatically at startup.</p> <p>For documentation, see the defaults at src/utils/conf_defaults.toml.</p> <p>For Docker users, mount the config file when running the container:</p> <pre><code>docker run -v ./data:/hyle/data -v ./config.run:/hyle/config.toml -e HYLE_RUN_INDEXER=false -p 4321:4321 -p 1234:1234 ghcr.io/hyli-org/hyli:v0.12.1\ncp ./src/utils/conf_defaults.toml config.toml\n</code></pre> <p>For source users, copy the default config template:</p> <pre><code>cp ./src/utils/conf_defaults.toml config.toml\n</code></pre>"},{"location":"reference/local-node/#using-environment-variables","title":"Using environment variables","text":"<p>All variables can be customized on your single-node instance. The mapping uses 'HYLE_' as a prefix, then '__' where a '.' would be in the config file.</p> <p>e.g.</p> <p><code>id</code> is set with <code>HYLE_ID=\"your_id\"</code>. <code>run_indexer</code> is set with <code>HYLE_RUN_INDEXER=\"true\"</code>. <code>p2p.address</code> is set with <code>HYLE_P2P__ADDRESS=\"127.0.0.1:4321\"</code> (note the double __ for the dot).</p>"},{"location":"reference/node/","title":"Community validators","text":""},{"location":"reference/node/#community-validators","title":"Community validators","text":"<p>We\u2019re not actively expanding validator capacity at the moment, but feel free to leave your contact information: we\u2019ll definitely reach out when new opportunities arise.</p> <p>Let's get in touch</p>"},{"location":"reference/supported-proving-schemes/","title":"Supported proving schemes","text":""},{"location":"reference/supported-proving-schemes/#supported-proving-schemes","title":"Supported proving schemes","text":"<p>Clone a template or write your own program to get started with app writing.</p> Proving scheme Verifier Program ID Example app Noir noir Verification key. check_secret Risc0 risc0 Image ID without a prefix. ex. 0x123 becomes 123. eZKasino SP1 sp1 Verification key. Faucet"},{"location":"reference/supported-proving-schemes/#noir","title":"Noir","text":"<p>Because Noir is a circuit-based ZK-language, you have to define the maximum size of the state at the contract creation. For simplicity, we recommend keeping Noir for stateless contracts:</p> <ul> <li>A stateless contract in Noir for private inputs and the logic linked to them.</li> <li>A stateful contract in Rust using Risc0 or SP1 to store the private state onchain.</li> </ul> <p>Proof composition allows you to leverage the privacy of Noir and ease of use of zkVMs.</p>"},{"location":"resources/","title":"\ud83d\udcda Resources","text":""},{"location":"resources/#resources","title":"\ud83d\udcda Resources","text":"<ul> <li> <p> Roadmap</p> <p>Our upcoming launches.</p> <p> Roadmap</p> </li> <li> <p> Release notes</p> <p>See all release notes and migration guides in one place.</p> <p> Release notes</p> </li> <li> <p> Contribute</p> <p>Contribute to Hyli through hackathons and grants.</p> <p> Grants</p> </li> <li> <p> Partnerships</p> <p>Let's work together.</p> <p> Partnerships</p> </li> <li> <p> Glossary</p> <p>Understand our vocabulary</p> <p> Glossary</p> </li> <li> <p> Find us</p> <p>Find us on social media.</p> <p> Find us</p> </li> </ul>"},{"location":"resources/find-us/","title":"Find us","text":""},{"location":"resources/find-us/#useful-links","title":"Useful links","text":"<ul> <li> Node</li> <li> Example contracts</li> <li> Website</li> <li> Hyli blog</li> </ul>"},{"location":"resources/find-us/#talk-about-us","title":"Talk about us","text":"<ul> <li>Media hub</li> <li>Visual assets</li> </ul>"},{"location":"resources/find-us/#contact-us","title":"Contact us","text":"<p>Reach out to the team for more information:</p>  Github  Twitter  Farcaster  LinkedIn  Youtube  Telegram Hyli @hyli_org @Hyli Hyli @Hyli Hyli"},{"location":"resources/glossary/","title":"Glossary","text":""},{"location":"resources/glossary/#glossary","title":"Glossary","text":"Term Definition Related concept page base state The state of an app before an operation occurs. Transactions blob A piece of provable information that is sent to Hyli. Apps blob transaction A transaction including a provable blob, used for sequencing. Pipelined proving cross-contract composition The ability to use and verify a contract's proofs in other contracts. Proof composition operation Something that happens on an unchained app. An operation includes two transactions: a blob transaction and a proof transaction. Transactions proof composition The process of combining multiple zero-knowledge proofs into a single proof, enabling efficient verification and interoperability across different proving systems. Proof composition proof transaction A transaction including a proof of a previously-submitted blob, used for verification and settlement. Transactions proof verification The act by which Hyli verifies submitted proofs before settling them onchain. Transactions timeout A time window after which, if no proof transaction has been submitted, an operation fails. Pipelined proving transaction A part of an operation that gets sent to Hyli. There are two types of transactions: blob transactions and proof transactions. Transactions"},{"location":"resources/grants/","title":"Contribute to Hyli","text":""},{"location":"resources/grants/#contribute-to-hyli","title":"Contribute to Hyli","text":""},{"location":"resources/grants/#contribution-opportunities","title":"Contribution opportunities","text":"<p>You can contribute to Hyli in several ways. All our code is open source and you can create issues and submit PRs.</p> <p>You can also check out our Careers page for longer-term opportunities.</p>"},{"location":"resources/partnerships/","title":"Partnerships","text":""},{"location":"resources/partnerships/#partnerships","title":"Partnerships","text":"<p>We are always open to technical and product discussions with potential partners!</p> <p>Let's get in touch</p>"},{"location":"resources/partnerships/#prover-network-zkvm","title":"Prover network / zkVM","text":"<p>We need proving power, you have it.</p> <p>The usual partnership: we integrate your zkVM or prover stack as a client, providing proof generation workloads as part of our settlement and verification pipeline.</p> <p>Read more: Proof generation and submission</p>"},{"location":"resources/partnerships/#raas-rollup-as-a-service","title":"RaaS (Rollup as a service)","text":"<p>When you integrate us as providers, your clients get:</p> <ul> <li>Ultra-fast finality via our high-throughput DA layer and shared sequencing</li> <li>Native composability across the entire Hyli ecosystem, regardless of the proof system used</li> <li>The ability to offer your clients seamless deployment of vApps into production</li> <li>Significant reduction in proof-generation latency, allowing for near-instant settlement cycles</li> </ul>"},{"location":"resources/partnerships/#zk-hardware","title":"ZK hardware","text":"<p>Your hardware can accelerate proof generation for Hyli-based rollups and applications. We are actively exploring hardware partnerships to push latency and efficiency boundaries even further.</p>"},{"location":"resources/partnerships/#applications","title":"Applications","text":"<p>With Hyli, adding verifiable computation is straightforward: use Rust, integrate a zkVM, and deploy. We're particularly interested in supporting applications around DeFi, identity, gaming, payments, AI, zkML, and voting.</p> <p>Thanks to native signature support and flexible zkVM abstraction, your app benefits from full onchain verifiability while retaining a familiar developer experience.</p> <p>Of course, our entire docs are also here for you!</p>"},{"location":"resources/partnerships/#validator-node-operator","title":"Validator / node operator","text":"<p>See community validators.</p> <p>Let's get in touch</p>"},{"location":"resources/release-notes/","title":"Release notes","text":""},{"location":"resources/release-notes/#release-notes","title":"Release notes","text":"<p>Read our full changelogs on GitHub or the short versions in our Telegram group.</p>"},{"location":"resources/release-notes/#2025-02-24-v0120","title":"2025-02-24 \u2212 v0.12.0","text":"<p>\ud83d\uddde\ufe0f Our news:</p> <ul> <li>All examples have been updated to v0.11.0</li> <li>We\u2019ve added Metamask authentication to our demo AMM, Hyleoof. We\u2019re looking forward to making the demo fully public!</li> </ul> <p>\ud83d\udca5 Breaking changes:</p> <p>We heard your feedback on our frequent breaking changes. Going forward, we\u2019ll be making fewer releases, relying instead on <code>rc</code> versions, so that breaking changes are batched.</p> <ul> <li>Contract input now uses state instead of state digest, which simplifies the API.</li> <li>SP1 verifier is now a separate feature: this drastically shortens build time if you\u2019re not using it.</li> <li>We\u2019ve improved the general structure of apps.</li> </ul> <p>\u2728 New features:</p> <ul> <li>We have a JS SDK now!</li> </ul> <p>\ud83d\ude85 Improvements:</p> <ul> <li>Added caching for computed hash, which doubles performance in heavy load situations</li> <li>Other big performance improvements for in-memory storage</li> </ul> <p>\ud83d\udee0\ufe0f No longer broken:</p> <ul> <li>Added missing data proposal hashes in blocks</li> <li>Fixed blob proof output index logic at settlement stage</li> </ul> <p>\ud83d\udcda Documentation:</p> <ul> <li>Added explanations to our proof composition concept page</li> </ul>"},{"location":"resources/release-notes/#2025-02-14-v0110","title":"2025-02-14 \u2212 v0.11.0","text":"<p>\u2728 New features:</p> <ul> <li>Added Mempool status event <code>data proposal created</code></li> <li>When a parent transaction times out, the timeout window for the child transactions is reset</li> </ul> <p>\ud83d\ude85 Improvements:</p> <ul> <li>Bumped risc0 from 1.2.2 to 1.2.3 and sp1 from 4.0.1 to 4.1.1</li> <li>Improved several logs, making them more specific or adding context to them, especially on error logs</li> <li>Improved storage to make it more compact</li> </ul> <p>\ud83d\udee0\ufe0f No longer broken:</p> <ul> <li>The Mempool status event <code>wait dissemination</code> now works for the first data proposal (genesis)</li> <li>The indexer client now gets blobs\u2019 endpoints</li> <li>Fixed the input encoding for the bonsai runner</li> </ul> <p>\ud83d\udcda Documentation:</p> <ul> <li>Revamped homepage and in-docs navigation</li> <li>Made some improvements for clarity to our pipelined proving concept page</li> <li>Added a page on proof generation and submission</li> </ul>"},{"location":"resources/release-notes/#2025-02-07-v0100","title":"2025-02-07 \u2212 v0.10.0","text":"<p>\ud83d\udca5 Breaking change: we\u2019ve replaced our serialization standard, bincode, with borsh. Encoding BlobData from JS didn\u2019t work properly with bincode: borsh offers better support and opens new possibilities!</p> <p>\u2728 New features:</p> <ul> <li>Introduced an indexer endpoint that adds events to BlobTXs: if your transaction didn\u2019t settle, you can now debug its flow much more easily!</li> <li>Introduced fees in ConsensusProposal. This has no external impact at this time.</li> <li>Added Mempool status event <code>waiting_dissemination</code></li> </ul> <p>\ud83d\udee0\ufe0f No longer broken:</p> <ul> <li>Hyllar Indexer now computes the correct caller in proof composition cases.</li> <li>Fixed a bug where the client couldn\u2019t close the websocket.</li> </ul>"},{"location":"resources/release-notes/#2025-02-03-v090","title":"2025-02-03 \u2212 v0.9.0","text":"<p>\ud83d\udca5 Breaking changes:</p> <ul> <li>Added transactions context (block, timestamp, \u2026) to proofs for more flexibility</li> </ul> <p>\u2728 New features:</p> <ul> <li>You can now start a node with an indexer and postgres database simply with <code>cargo run -- --pg</code></li> <li>Added an endpoint for contract registration</li> </ul> <p>\ud83d\ude85 Improvements:</p> <ul> <li>Updated risc0 to 1.2.2</li> <li>Made logging less spammy and more informative (incl. logging timeouts as info)</li> <li>Improved the transaction builder tool in the SDK</li> </ul> <p>\ud83d\udee0\ufe0f No longer broken:</p> <ul> <li>Contract state indexers are now fully saved upon restart</li> <li>Staking contracts now check that there is a <code>transfer</code> blob</li> <li>The Rust version enforced in cargo is less restrictive</li> </ul> <p>\ud83d\udcda Documentation:</p> <ul> <li>Updated our examples so they work with 0.9.0!</li> <li>Added OpenAPI documentation on contract state indexers</li> <li>Added a swagger for the node and its indexer</li> </ul> <p>Quick note: release notes will be published on Fridays instead of Mondays from now on. See you in just a few days!</p>"},{"location":"resources/release-notes/#2025-01-27-v080","title":"2025-01-27 \u2212 v0.8.0","text":"<p>\ud83d\udca5 Breaking changes:</p> <ul> <li>Hyle-contracts: Merged the contracts \u2018metadata\u2019 feature into \u2018client\u2019</li> <li>There are no more <code>RegisterContract</code> transactions: contracts are now registered with <code>BlobTransactions</code>, like everything else.</li> <li>Contract registration has been reworked using proof outputs; we introduced UUID contract names (see uuid-tld for an example).</li> <li>Removed <code>hyled</code> and <code>hyrun</code>. If you were using them, check out our SDK instead.</li> </ul> <p>\u2728New features:</p> <ul> <li>You can now settle transactions that have a proof of failure before they timeout</li> <li>Made progress on the implementation of our consensus</li> </ul> <p>\ud83d\ude85 Improvements:</p> <ul> <li>We now enforce a recent Rust version to avoid errors.</li> </ul> <p>\ud83d\udee0\ufe0f No longer broken:</p> <ul> <li>Bug fixes include Dockerfile, environment variables, and identities.</li> </ul> <p>\ud83d\udcda Documentation:</p> <ul> <li>Our SDK has a README now!</li> </ul> <p>Read the full changelog on GitHub.</p>"},{"location":"resources/release-notes/#2025-01-21-v071-v072","title":"2025-01-21 \u2212 v0.7.1 &amp; v0.7.2","text":"<p>Small patches for our SDK.</p> <p>Read release notes for v0.7.1 and v0.7.2; see new SDK readme for more info.</p>"},{"location":"resources/release-notes/#2025-01-20-v070","title":"2025-01-20 \u2212 v0.7.0","text":"<p>\ud83d\udca5 Breaking changes:</p> <ul> <li>We completely rewrote the dependencies for the SDK.</li> </ul> <p>\u2728 New features;</p> <ul> <li>Adding support of native verifiers. Verify hash signatures, TEE executions without needing a ZK proof! Currently supported: sha3_256 &amp; BLST signatures.</li> <li>You can now use <code>tx hash</code> inside contracts</li> </ul> <p>\ud83d\ude85 Improvements:</p> <ul> <li>Several performance improvements following our latest loadtest</li> <li>Reduce log verbosity and frequency</li> <li>Dependencies: updated risc0-zkvm to 1.2.1, sp1-sdk to 4.0.0</li> </ul> <p>\ud83d\udee0\ufe0f No longer broken:</p> <ul> <li>Loads of bug fixes \u2212 check the full release to know more.</li> </ul> <p>\ud83d\udcda Documentation:</p> <ul> <li>Transactions on Hyli</li> <li>Identity management</li> </ul> <p>Read the full changelog on GitHub and receive future release notes in our Telegram group.</p>"},{"location":"resources/release-notes/#2025-01-13-v060","title":"2025-01-13 \u2212 v0.6.0","text":"<p>\u2728 New features:</p> <ul> <li>Added the SP1 prover to the client SDK.</li> </ul> <p>\ud83d\ude85 Improvements:</p> <ul> <li>Upgraded to SP1 4.0.0-rc8.</li> </ul> <p>\ud83d\udee0\ufe0f No longer broken:</p> <ul> <li>Fixed the default configurations.</li> <li>Fixed loading state when restarting a node.</li> </ul> <p>\ud83d\udcda Documentation:</p> <ul> <li>Rewrote our Quickstart guide.</li> </ul> <p>Read the full changelog on GitHub and receive future release notes in our Telegram group.</p>"},{"location":"resources/roadmap/","title":"Roadmap","text":""},{"location":"resources/roadmap/#testnet","title":"Testnet","text":"<p>Our private testnet is live and can be accessed with invite codes. Invite codes will be shared on social media channels.</p> <p>Stay tuned for updates or ask specific questions in our Telegram group.</p> <p>While we\u2019re working, you can get hands-on right now: create your first app on Hyli!</p>"},{"location":"resources/roadmap/#proving-schemes","title":"Proving schemes","text":"<p>Check the list of the proving schemes we currently support and the ones we'll work on next.</p>"},{"location":"tooling/","title":"\ud83e\uddf0 Tooling","text":""},{"location":"tooling/#tooling","title":"Tooling","text":"<p>Here, you'll find our resources about Hyli's tooling.</p> <ul> <li> <p> Explorer</p> <p>Use the Hyli explorer.</p> <p> Read more</p> </li> <li> <p> Explorer</p> <p>Use the Hyli wallet.</p> <p> Read more</p> </li> <li> <p> API and SDK</p> <p>Explore our API and use the helper functions in our contract SDK.</p> <p> Read more</p> </li> </ul>"},{"location":"tooling/api/","title":"API and SDK","text":""},{"location":"tooling/api/#api-and-sdk","title":"API and SDK","text":"<p>Hyli's API allows you to interact with its core components.</p>"},{"location":"tooling/api/#openapi-documentation","title":"OpenAPI documentation","text":"<p>To explore available endpoints and understand the API structure:</p> <ol> <li>Run a local node.</li> <li>Open http://localhost:4321/swagger-ui/.</li> </ol> <p>Or visit https://indexer.testnet.hyli.org/swagger-ui/ for an indexer-only api documentation.</p>"},{"location":"tooling/api/#sdk-implementations","title":"SDK implementations","text":"<p>We currently support Rust and JS environments.</p> Language Repository / Package JS hyli on npm Rust hyle client sdk on docs.rs"},{"location":"tooling/explorer/","title":"Explorer","text":""},{"location":"tooling/explorer/#explorer","title":"Explorer","text":"<p>Open the explorer</p>"},{"location":"tooling/wallet/","title":"Using the Hyli wallet","text":""},{"location":"tooling/wallet/#using-the-hyli-wallet","title":"Using the Hyli wallet","text":"<p>On most blockchains, your identity is your wallet address. On Hyli, identity is a flexible set of credentials verified by a smart contract.</p> <p>On Hyli, any smart contract can function as a verifiable proof of identity. This enables fine-grained access control and varied authentication mechanisms where each app can rely on the most appropriate form of identity verification: OIDC, password-based, and zkPassport are all valid sources of ID that are relevant in different contexts.</p> <p>While extremely flexible, identity management on Hyli can create some complexity for users and developers. So we created the Hyli wallet as an identity hub to offer a unified experience with all Hyli apps.</p> <p>The Hyli Wallet acts as a gateway to onchain identity. It lets users:</p> <ul> <li>register multiple authentication methods,</li> <li>generate app-specific session keys,</li> <li>authenticate without exposing private data.</li> </ul> <p>This creates a unified identity layer for seamless interaction across apps on Hyli.</p>"},{"location":"tooling/wallet/#supported-identity-sources","title":"Supported identity sources","text":"<p>Currently, the wallet is compatible with the following identity sources:</p> <ul> <li>Username and password</li> </ul> <p>Want to use another identity source? Use our identity guide!</p>"},{"location":"tooling/wallet/#user-experience-with-the-hyli-wallet","title":"User experience with the Hyli wallet","text":""},{"location":"tooling/wallet/#create-a-wallet","title":"Create a wallet","text":"<p>Creating the Hyli wallet is done, as with everything else on Hyli, by sending a transaction. The transaction includes two blobs:</p> <ol> <li>A <code>CheckSecret</code> blob takes the user\u2019s password as private input and asserts that the hash is correct;</li> <li>A <code>registerAccount</code> blob verifies and stores the user\u2019s Hyli identity, <code>max@wallet</code>, in its state.</li> </ol> <p>The CheckSecret contract is written in Noir; see the source code on GitHub.</p>"},{"location":"tooling/wallet/#create-a-session-key","title":"Create a session key","text":"<p>The user can create a session key on any app. A session key includes a public key and a private key.</p>"},{"location":"tooling/wallet/#register-the-session-key","title":"Register the session key","text":"<p>The user registers their session key in a new transaction, which, again, includes two blobs:</p> <ol> <li>A <code>CheckSecret</code> blob makes sure that the password is correct, meaning that the user is correctly authenticated;</li> <li>A <code>registerSessionKey</code> blob registers the public key as a session key associated with the user\u2019s account and adds the new contract to the allowlist.</li> </ol> <p>Now, the session key is linked to the user\u2019s wallet. This means that the user can use their wallet to interact with the allowlisted contract.</p>"},{"location":"tooling/wallet/#use-the-session-key-for-a-future-action","title":"Use the session key for a future action","text":"<p>When interacting with the allowlisted contract, the transaction will include three blobs:</p> <ol> <li>A blob to verify the user\u2019s signature using the private key. The blob signs a timestamp and is used to update the session key\u2019s nonce.</li> <li>A blob to verify the session key, asserting that the key used for the signature in the first blob is associated with the user\u2019s account.</li> <li>A blob for the transfer itself.</li> </ol>"},{"location":"tooling/wallet/#why-use-the-hyli-wallet","title":"Why use the Hyli wallet?","text":"<p>With this architecture, interacting with a smart contract does not require any private input in the zkVM. The signature is verified natively without requiring the generation of a zero-knowledge proof for this blob.</p> <p>The two other blobs don\u2019t require authentication, as the authentication blob works for the entire transaction thanks to Hyli\u2019s native proof composition.</p> <p>This has the added benefit of avoiding timeouts. Since there are no private inputs, anyone can verify every blob in the transaction without worrying too much about privacy, and there is no bottleneck in verification times, as there could be if there were invalid data in a private input. Apps can externalize proving without worrying about security.</p>"},{"location":"tooling/wallet/#building-with-the-hyli-wallet","title":"Building with the Hyli wallet","text":""},{"location":"tooling/wallet/#clone-the-repository","title":"Clone the repository","text":"<p>Clone the Hyli wallet repository.</p>"},{"location":"tooling/wallet/#install","title":"Install","text":"<pre><code>npm install hyli-wallet\n# or\nyarn add hyli-wallet\n</code></pre> <p>Note the following peer dependencies:</p> <pre><code>{\n    \"hyli-check-secret\": \"^0.3.2\",\n    \"react\": \"^19.1.0\",\n    \"react-dom\": \"^19.1.0\",\n    \"react-router-dom\": \"^7.5.0\"\n}\n</code></pre>"},{"location":"tooling/wallet/#basic-usage","title":"Basic Usage","text":""},{"location":"tooling/wallet/#wrap-your-application","title":"Wrap your application","text":"<p>First, wrap your application with the <code>WalletProvider</code>:</p> <pre><code>import { WalletProvider } from \"hyli-wallet\";\n\nfunction App() {\n    return (\n        &lt;WalletProvider\n            config={{\n                nodeBaseUrl: \"NODE_BASE_URL\",\n                walletServerBaseUrl: \"WALLET_SERVER_URL\",\n                applicationWsUrl: \"WEBSOCKET_URL\",\n            }}\n            // Optional: session key config\n            sessionKeyConfig={{\n                duration: 24 * 60 * 60 * 1000, // Session key duration in ms (default: 72h)\n                whitelist: [], // Required: contracts allowed for session key\n            }}\n            // Optional: global wallet event handler\n            onWalletEvent={(event) =&gt; {\n                console.log(\"Wallet event:\", event);\n            }}\n            // Optional: global wallet error handler\n            onError={(error) =&gt; {\n                console.error(\"Wallet error:\", error);\n            }}\n        &gt;\n            &lt;YourApp /&gt;\n        &lt;/WalletProvider&gt;\n    );\n}\n</code></pre>"},{"location":"tooling/wallet/#use-the-wallet-component","title":"Use the wallet component","text":"<pre><code>import { HyliWallet } from \"hyli-wallet\";\n\nfunction YourComponent() {\n    return (\n        &lt;HyliWallet\n            providers={[\"password\", \"google\", \"github\"]} // Optional: specify auth providers\n        /&gt;\n    );\n}\n</code></pre>"},{"location":"tooling/wallet/#use-the-wallet-hook","title":"Use the Wallet Hook","text":"<p>The <code>useWallet</code> hook provides access to wallet functionality.</p> <pre><code>import { useWallet } from \"hyli-wallet\";\n\nfunction WalletFeatures() {\n    const {\n        wallet, // Current wallet state\n        isLoading,\n        error,\n        login, // Login function\n        registerAccount, // Create new account\n        logout, // Logout function\n        registerSessionKey, // Create new session key\n        removeSessionKey, // Remove existing session key\n        signMessageWithSessionKey, // Sign a message with the current session key\n    } = useWallet();\n\n    return (\n        &lt;div&gt;\n            {wallet ? (\n                &lt;div&gt;\n                    &lt;p&gt;Welcome, {wallet.username}&lt;/p&gt;\n                    &lt;p&gt;Balance: {balance} HYLLAR&lt;/p&gt;\n                    &lt;button onClick={logout}&gt;Logout&lt;/button&gt;\n                &lt;/div&gt;\n            ) : (\n                &lt;p&gt;Please connect your wallet&lt;/p&gt;\n            )}\n        &lt;/div&gt;\n    );\n}\n</code></pre>"},{"location":"tooling/wallet/#session-key-management","title":"Session key management","text":"<p>Find a full implementation of session keys in SessionKeys.tsx.</p>"},{"location":"tooling/wallet/#creating-a-session-key","title":"Creating a session key","text":"<p>Session keys allow for delegated transaction signing. Here's how to create one:</p> <pre><code>import { useWallet } from 'hyli-wallet';\n\nconst { wallet, registerSessionKey } = useWallet();\n\n// Create a session key that expires in 7 days\nconst expiration = Date.now() + (7 * 24 * 60 * 60 * 1000);\n\nconst { sessionKey } = await registerSessionKey(\n  'your_password',\n  expiration,\n  ['hyllar'] // contracts whitelist\n  (txHash: string, type: string) =&gt; {\n     if (type === 'blob') {\n       console.log('Verifying identity...');\n       console.log(\"transaction hash: \", txHash);\n     } else if (type === 'proof') {\n       console.log('Proof sent, waiting for confirmation...');\n       console.log(\"transaction hash: \", txHash);\n     }\n   }\n);\n\n// The sessionKey object contains:\nconsole.log(sessionKey.publicKey);  // The public key to identify the session\nconsole.log(sessionKey.privateKey); // The private key to sign transactions\n// Note that this session key will also be stored in the wallet object\n</code></pre>"},{"location":"tooling/wallet/#signing-a-transaction-with-a-session-key","title":"Signing a transaction with a session key","text":"<p>Once you have a session key, you can use it to send transactions.</p> <pre><code>import { useWallet } from \"hyli-wallet\";\nimport { nodeService } from \"your-services\";\n\nconst { wallet, createIdentityBlobs } = useWallet();\n\n// Create identity blobs using the latest created session key, stored in  `wallet` object\nconst [blob0, blob1] = createIdentityBlobs();\n\n// Create and send the transaction\nconst blobTx = {\n    identity: wallet.address,\n    blobs: [blob0, blob1],\n};\n// blob0 is the secp256k1 blob containing the signature done with the wallet's session keu\n// blob1 is the hyli-wallet contract that verifies that the session key is valid\n\nconst txHash = await nodeService.client.sendBlobTx(blobTx);\nconsole.log(\"Transaction sent:\", txHash);\n</code></pre>"},{"location":"tooling/wallet/#removing-a-session-key","title":"Removing a session key","text":"<p>When a session key is no longer needed, you can remove it:</p> <pre><code>import { useWallet } from \"hyli-wallet\";\n\nconst { removeSessionKey } = useWallet();\n\n// Remove the session key using the wallet password\nawait removeSessionKey(\"your_password\", \"session_key_public_key\");\n</code></pre>"},{"location":"tooling/wallet/#signing-arbitrary-messages-with-a-session-key","title":"Signing arbitrary messages with a session key","text":"<p>You can sign any message using the current session key.</p> <pre><code>import { useWallet } from \"hyli-wallet\";\n\nconst { signMessageWithSessionKey } = useWallet();\n\nconst message = \"Hello, Hyli!\";\nconst { hash, signature } = signMessageWithSessionKey(message);\n\nconsole.log(\"Message hash (Uint8Array):\", hash);\nconsole.log(\"Signature (Uint8Array):\", signature);\n</code></pre> <ul> <li><code>signMessageWithSessionKey(message: string)</code> will throw if there is no session key in the wallet.</li> <li>The raw hash and signature return as <code>Uint8Array</code>.</li> </ul>"},{"location":"tooling/wallet/#websocket-integration","title":"WebSocket integration","text":"<p>Real-time updates for transactions and wallet events:</p> <pre><code>function TransactionMonitor() {\n    useWebSocketConnection(wallet?.address, (event) =&gt; {\n        if (event.tx.status === \"Success\") {\n            // Handle successful transaction\n            fetchBalance();\n        }\n    });\n}\n</code></pre>"},{"location":"tooling/wallet/#customizing-the-user-interface","title":"Customizing the user interface","text":"<p>You can customize the connect button by providing a render prop:</p> <pre><code>&lt;HyliWallet\n    button={({ onClick }) =&gt; (\n        &lt;button className=\"custom-button\" onClick={onClick}&gt;\n            Connect to Wallet\n        &lt;/button&gt;\n    )}\n/&gt;\n</code></pre>"},{"location":"tooling/wallet/#web-component","title":"Web component","text":"<p>The library also provides a web component for non-React applications:</p> <pre><code>&lt;script type=\"module\" src=\"path/to/hyli-wallet/dist/hyli-wallet.es.js\"&gt;&lt;/script&gt;\n&lt;hyli-wallet providers=\"password,google\"&gt;&lt;/hyli-wallet&gt;\n</code></pre>"}]}